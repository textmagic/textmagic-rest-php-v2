<?php
/**
 * TextMagicApi
 * PHP version 8.1
 *
 * @category Class
 * @package  TextMagic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Textmagic API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.17.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TextMagic\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use TextMagic\ApiException;
use TextMagic\Configuration;
use TextMagic\FormDataProcessor;
use TextMagic\HeaderSelector;
use TextMagic\ObjectSerializer;

/**
 * TextMagicApi Class Doc Comment
 *
 * @category Class
 * @package  TextMagic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TextMagicApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'assignContactsToList' => [
            'application/json',
        ],
        'blockContact' => [
            'application/json',
        ],
        'buyDedicatedNumber' => [
            'application/json',
        ],
        'clearAndAssignContactsToList' => [
            'application/json',
        ],
        'closeChatsBulk' => [
            'application/json',
        ],
        'closeReadChats' => [
            'application/json',
        ],
        'createContact' => [
            'application/json',
        ],
        'createContactNote' => [
            'application/json',
        ],
        'createCustomField' => [
            'application/json',
        ],
        'createEmailCampaign' => [
            'application/json',
        ],
        'createList' => [
            'application/json',
        ],
        'createTag' => [
            'application/json',
        ],
        'createTemplate' => [
            'application/json',
        ],
        'deleteAllContacts' => [
            'application/json',
        ],
        'deleteAllOutboundMessages' => [
            'application/json',
        ],
        'deleteAvatar' => [
            'application/json',
        ],
        'deleteChatMessages' => [
            'application/json',
        ],
        'deleteChatsBulk' => [
            'application/json',
        ],
        'deleteContact' => [
            'application/json',
        ],
        'deleteContactAvatar' => [
            'application/json',
        ],
        'deleteContactNote' => [
            'application/json',
        ],
        'deleteContactNotesBulk' => [
            'application/json',
        ],
        'deleteContactsByIds' => [
            'application/json',
        ],
        'deleteContactsFromList' => [
            'application/json',
        ],
        'deleteCustomField' => [
            'application/json',
        ],
        'deleteDedicatedNumber' => [
            'application/json',
        ],
        'deleteInboundMessage' => [
            'application/json',
        ],
        'deleteInboundMessagesBulk' => [
            'application/json',
        ],
        'deleteList' => [
            'application/json',
        ],
        'deleteListAvatar' => [
            'application/json',
        ],
        'deleteListContactsBulk' => [
            'application/json',
        ],
        'deleteListsBulk' => [
            'application/json',
        ],
        'deleteMessageSession' => [
            'application/json',
        ],
        'deleteMessageSessionsBulk' => [
            'application/json',
        ],
        'deleteOutboundMessage' => [
            'application/json',
        ],
        'deleteOutboundMessagesBulk' => [
            'application/json',
        ],
        'deleteScheduledMessage' => [
            'application/json',
        ],
        'deleteScheduledMessagesBulk' => [
            'application/json',
        ],
        'deleteSenderId' => [
            'application/json',
        ],
        'deleteTemplate' => [
            'application/json',
        ],
        'deleteTemplatesBulk' => [
            'application/json',
        ],
        'doCarrierLookup' => [
            'application/json',
        ],
        'doEmailLookup' => [
            'application/json',
        ],
        'getAllBulkSessions' => [
            'application/json',
        ],
        'getAllChats' => [
            'application/json',
        ],
        'getAllInboundMessages' => [
            'application/json',
        ],
        'getAllMessageSessions' => [
            'application/json',
        ],
        'getAllOutboundMessages' => [
            'application/json',
        ],
        'getAllScheduledMessages' => [
            'application/json',
        ],
        'getAllTemplates' => [
            'application/json',
        ],
        'getAvailableDedicatedNumbers' => [
            'application/json',
        ],
        'getAvailableSenderSettingOptions' => [
            'application/json',
        ],
        'getBalanceNotificationOptions' => [
            'application/json',
        ],
        'getBalanceNotificationSettings' => [
            'application/json',
        ],
        'getBlockedContacts' => [
            'application/json',
        ],
        'getBulkSession' => [
            'application/json',
        ],
        'getCallbackSettings' => [
            'application/json',
        ],
        'getChat' => [
            'application/json',
        ],
        'getChatByPhone' => [
            'application/json',
        ],
        'getChatMessages' => [
            'application/json',
        ],
        'getContact' => [
            'application/json',
        ],
        'getContactByPhone' => [
            'application/json',
        ],
        'getContactIfBlocked' => [
            'application/json',
        ],
        'getContactImportSessionProgress' => [
            'application/json',
        ],
        'getContactNote' => [
            'application/json',
        ],
        'getContactNotes' => [
            'application/json',
        ],
        'getContacts' => [
            'application/json',
        ],
        'getContactsByListId' => [
            'application/json',
        ],
        'getCurrentUser' => [
            'application/json',
        ],
        'getCustomField' => [
            'application/json',
        ],
        'getCustomFields' => [
            'application/json',
        ],
        'getDedicatedNumber' => [
            'application/json',
        ],
        'getEmailSenders' => [
            'application/json',
        ],
        'getFavorites' => [
            'application/json',
        ],
        'getInboundMessage' => [
            'application/json',
        ],
        'getInboundMessagesNotificationSettings' => [
            'application/json',
        ],
        'getInvoices' => [
            'application/json',
        ],
        'getList' => [
            'application/json',
        ],
        'getListContactsIds' => [
            'application/json',
        ],
        'getLists' => [
            'application/json',
        ],
        'getListsOfContact' => [
            'application/json',
        ],
        'getMessagePreview' => [
            'application/json',
        ],
        'getMessagePrice' => [
            'application/json',
        ],
        'getMessageSession' => [
            'application/json',
        ],
        'getMessageSessionStat' => [
            'application/json',
        ],
        'getMessagesBySessionId' => [
            'application/json',
        ],
        'getMessagingCounters' => [
            'application/json',
        ],
        'getOutboundMessage' => [
            'application/json',
        ],
        'getOutboundMessagesHistory' => [
            'application/json',
        ],
        'getScheduledMessage' => [
            'application/json',
        ],
        'getSenderId' => [
            'application/json',
        ],
        'getSenderIds' => [
            'application/json',
        ],
        'getSenderSettings' => [
            'application/json',
        ],
        'getSpendingStat' => [
            'application/json',
        ],
        'getTemplate' => [
            'application/json',
        ],
        'getUnreadMessagesTotal' => [
            'application/json',
        ],
        'getUnsubscribedContact' => [
            'application/json',
        ],
        'getUnsubscribers' => [
            'application/json',
        ],
        'getUserDedicatedNumbers' => [
            'application/json',
        ],
        'importContacts' => [
            'multipart/form-data',
        ],
        'markChatsReadBulk' => [
            'application/json',
        ],
        'markChatsUnreadBulk' => [
            'application/json',
        ],
        'muteChat' => [
            'application/json',
        ],
        'muteChatsBulk' => [
            'application/json',
        ],
        'ping' => [
            'application/json',
        ],
        'reopenChatsBulk' => [
            'application/json',
        ],
        'requestSenderId' => [
            'application/json',
        ],
        'scheduleEmailCampaign' => [
            'application/json',
        ],
        'searchChats' => [
            'application/json',
        ],
        'searchChatsByIds' => [
            'application/json',
        ],
        'searchChatsByReceipent' => [
            'application/json',
        ],
        'searchContacts' => [
            'application/json',
        ],
        'searchInboundMessages' => [
            'application/json',
        ],
        'searchLists' => [
            'application/json',
        ],
        'searchOutboundMessages' => [
            'application/json',
        ],
        'searchScheduledMessages' => [
            'application/json',
        ],
        'searchTemplates' => [
            'application/json',
        ],
        'sendMessage' => [
            'application/json',
        ],
        'setChatStatus' => [
            'application/json',
        ],
        'unblockContact' => [
            'application/json',
        ],
        'unblockContactsBulk' => [
            'application/json',
        ],
        'unmuteChatsBulk' => [
            'application/json',
        ],
        'unsubscribeContact' => [
            'application/json',
        ],
        'updateBalanceNotificationSettings' => [
            'application/json',
        ],
        'updateCallbackSettings' => [
            'application/json',
        ],
        'updateChatDesktopNotificationSettings' => [
            'application/json',
        ],
        'updateContact' => [
            'application/json',
        ],
        'updateContactNote' => [
            'application/json',
        ],
        'updateCurrentUser' => [
            'application/json',
        ],
        'updateCustomField' => [
            'application/json',
        ],
        'updateCustomFieldValue' => [
            'application/json',
        ],
        'updateInboundMessagesNotificationSettings' => [
            'application/json',
        ],
        'updateList' => [
            'application/json',
        ],
        'updateSenderSetting' => [
            'application/json',
        ],
        'updateTemplate' => [
            'application/json',
        ],
        'uploadAvatar' => [
            'multipart/form-data',
        ],
        'uploadContactAvatar' => [
            'multipart/form-data',
        ],
        'uploadListAvatar' => [
            'multipart/form-data',
        ],
        'uploadMessageAttachment' => [
            'multipart/form-data',
        ],
        'uploadMessageMMSAttachment' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation assignContactsToList
     *
     * Assign contacts to a list
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\AssignContactsToListRequest $assignContactsToListInputObject assignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignContactsToList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function assignContactsToList($id, $assignContactsToListInputObject, string $contentType = self::contentTypes['assignContactsToList'][0])
    {
        list($response) = $this->assignContactsToListWithHttpInfo($id, $assignContactsToListInputObject, $contentType);
        return $response;
    }

    /**
     * Operation assignContactsToListWithHttpInfo
     *
     * Assign contacts to a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\AssignContactsToListRequest $assignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignContactsToList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignContactsToListWithHttpInfo($id, $assignContactsToListInputObject, string $contentType = self::contentTypes['assignContactsToList'][0])
    {
        $request = $this->assignContactsToListRequest($id, $assignContactsToListInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation assignContactsToListAsync
     *
     * Assign contacts to a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\AssignContactsToListRequest $assignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignContactsToListAsync($id, $assignContactsToListInputObject, string $contentType = self::contentTypes['assignContactsToList'][0])
    {
        return $this->assignContactsToListAsyncWithHttpInfo($id, $assignContactsToListInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignContactsToListAsyncWithHttpInfo
     *
     * Assign contacts to a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\AssignContactsToListRequest $assignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignContactsToListAsyncWithHttpInfo($id, $assignContactsToListInputObject, string $contentType = self::contentTypes['assignContactsToList'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->assignContactsToListRequest($id, $assignContactsToListInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignContactsToList'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\AssignContactsToListRequest $assignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function assignContactsToListRequest($id, $assignContactsToListInputObject, string $contentType = self::contentTypes['assignContactsToList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling assignContactsToList'
            );
        }

        // verify the required parameter 'assignContactsToListInputObject' is set
        if ($assignContactsToListInputObject === null || (is_array($assignContactsToListInputObject) && count($assignContactsToListInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assignContactsToListInputObject when calling assignContactsToList'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($assignContactsToListInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($assignContactsToListInputObject));
            } else {
                $httpBody = $assignContactsToListInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation blockContact
     *
     * Block a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $blockContactInputObject blockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function blockContact($blockContactInputObject, string $contentType = self::contentTypes['blockContact'][0])
    {
        list($response) = $this->blockContactWithHttpInfo($blockContactInputObject, $contentType);
        return $response;
    }

    /**
     * Operation blockContactWithHttpInfo
     *
     * Block a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $blockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function blockContactWithHttpInfo($blockContactInputObject, string $contentType = self::contentTypes['blockContact'][0])
    {
        $request = $this->blockContactRequest($blockContactInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation blockContactAsync
     *
     * Block a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $blockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockContactAsync($blockContactInputObject, string $contentType = self::contentTypes['blockContact'][0])
    {
        return $this->blockContactAsyncWithHttpInfo($blockContactInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation blockContactAsyncWithHttpInfo
     *
     * Block a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $blockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockContactAsyncWithHttpInfo($blockContactInputObject, string $contentType = self::contentTypes['blockContact'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->blockContactRequest($blockContactInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'blockContact'
     *
     * @param  \TextMagic\Models\BlockContactRequest $blockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function blockContactRequest($blockContactInputObject, string $contentType = self::contentTypes['blockContact'][0])
    {

        // verify the required parameter 'blockContactInputObject' is set
        if ($blockContactInputObject === null || (is_array($blockContactInputObject) && count($blockContactInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockContactInputObject when calling blockContact'
            );
        }


        $resourcePath = '/api/v2/contacts/block';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($blockContactInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($blockContactInputObject));
            } else {
                $httpBody = $blockContactInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buyDedicatedNumber
     *
     * Buy a dedicated number
     *
     * @param  \TextMagic\Models\BuyDedicatedNumberRequest $buyDedicatedNumberInputObject buyDedicatedNumberInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function buyDedicatedNumber($buyDedicatedNumberInputObject, string $contentType = self::contentTypes['buyDedicatedNumber'][0])
    {
        $this->buyDedicatedNumberWithHttpInfo($buyDedicatedNumberInputObject, $contentType);
    }

    /**
     * Operation buyDedicatedNumberWithHttpInfo
     *
     * Buy a dedicated number
     *
     * @param  \TextMagic\Models\BuyDedicatedNumberRequest $buyDedicatedNumberInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function buyDedicatedNumberWithHttpInfo($buyDedicatedNumberInputObject, string $contentType = self::contentTypes['buyDedicatedNumber'][0])
    {
        $request = $this->buyDedicatedNumberRequest($buyDedicatedNumberInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation buyDedicatedNumberAsync
     *
     * Buy a dedicated number
     *
     * @param  \TextMagic\Models\BuyDedicatedNumberRequest $buyDedicatedNumberInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyDedicatedNumberAsync($buyDedicatedNumberInputObject, string $contentType = self::contentTypes['buyDedicatedNumber'][0])
    {
        return $this->buyDedicatedNumberAsyncWithHttpInfo($buyDedicatedNumberInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buyDedicatedNumberAsyncWithHttpInfo
     *
     * Buy a dedicated number
     *
     * @param  \TextMagic\Models\BuyDedicatedNumberRequest $buyDedicatedNumberInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyDedicatedNumberAsyncWithHttpInfo($buyDedicatedNumberInputObject, string $contentType = self::contentTypes['buyDedicatedNumber'][0])
    {
        $returnType = '';
        $request = $this->buyDedicatedNumberRequest($buyDedicatedNumberInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buyDedicatedNumber'
     *
     * @param  \TextMagic\Models\BuyDedicatedNumberRequest $buyDedicatedNumberInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function buyDedicatedNumberRequest($buyDedicatedNumberInputObject, string $contentType = self::contentTypes['buyDedicatedNumber'][0])
    {

        // verify the required parameter 'buyDedicatedNumberInputObject' is set
        if ($buyDedicatedNumberInputObject === null || (is_array($buyDedicatedNumberInputObject) && count($buyDedicatedNumberInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $buyDedicatedNumberInputObject when calling buyDedicatedNumber'
            );
        }


        $resourcePath = '/api/v2/numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($buyDedicatedNumberInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($buyDedicatedNumberInputObject));
            } else {
                $httpBody = $buyDedicatedNumberInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearAndAssignContactsToList
     *
     * Reset list members to the specified contacts
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\ClearAndAssignContactsToListRequest $clearAndAssignContactsToListInputObject clearAndAssignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clearAndAssignContactsToList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function clearAndAssignContactsToList($id, $clearAndAssignContactsToListInputObject, string $contentType = self::contentTypes['clearAndAssignContactsToList'][0])
    {
        list($response) = $this->clearAndAssignContactsToListWithHttpInfo($id, $clearAndAssignContactsToListInputObject, $contentType);
        return $response;
    }

    /**
     * Operation clearAndAssignContactsToListWithHttpInfo
     *
     * Reset list members to the specified contacts
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\ClearAndAssignContactsToListRequest $clearAndAssignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clearAndAssignContactsToList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearAndAssignContactsToListWithHttpInfo($id, $clearAndAssignContactsToListInputObject, string $contentType = self::contentTypes['clearAndAssignContactsToList'][0])
    {
        $request = $this->clearAndAssignContactsToListRequest($id, $clearAndAssignContactsToListInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation clearAndAssignContactsToListAsync
     *
     * Reset list members to the specified contacts
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\ClearAndAssignContactsToListRequest $clearAndAssignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clearAndAssignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearAndAssignContactsToListAsync($id, $clearAndAssignContactsToListInputObject, string $contentType = self::contentTypes['clearAndAssignContactsToList'][0])
    {
        return $this->clearAndAssignContactsToListAsyncWithHttpInfo($id, $clearAndAssignContactsToListInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearAndAssignContactsToListAsyncWithHttpInfo
     *
     * Reset list members to the specified contacts
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\ClearAndAssignContactsToListRequest $clearAndAssignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clearAndAssignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearAndAssignContactsToListAsyncWithHttpInfo($id, $clearAndAssignContactsToListInputObject, string $contentType = self::contentTypes['clearAndAssignContactsToList'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->clearAndAssignContactsToListRequest($id, $clearAndAssignContactsToListInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearAndAssignContactsToList'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\ClearAndAssignContactsToListRequest $clearAndAssignContactsToListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clearAndAssignContactsToList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clearAndAssignContactsToListRequest($id, $clearAndAssignContactsToListInputObject, string $contentType = self::contentTypes['clearAndAssignContactsToList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling clearAndAssignContactsToList'
            );
        }

        // verify the required parameter 'clearAndAssignContactsToListInputObject' is set
        if ($clearAndAssignContactsToListInputObject === null || (is_array($clearAndAssignContactsToListInputObject) && count($clearAndAssignContactsToListInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clearAndAssignContactsToListInputObject when calling clearAndAssignContactsToList'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($clearAndAssignContactsToListInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clearAndAssignContactsToListInputObject));
            } else {
                $httpBody = $clearAndAssignContactsToListInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation closeChatsBulk
     *
     * Close chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $closeChatsBulkInputObject closeChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function closeChatsBulk($closeChatsBulkInputObject, string $contentType = self::contentTypes['closeChatsBulk'][0])
    {
        $this->closeChatsBulkWithHttpInfo($closeChatsBulkInputObject, $contentType);
    }

    /**
     * Operation closeChatsBulkWithHttpInfo
     *
     * Close chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $closeChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function closeChatsBulkWithHttpInfo($closeChatsBulkInputObject, string $contentType = self::contentTypes['closeChatsBulk'][0])
    {
        $request = $this->closeChatsBulkRequest($closeChatsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation closeChatsBulkAsync
     *
     * Close chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $closeChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeChatsBulkAsync($closeChatsBulkInputObject, string $contentType = self::contentTypes['closeChatsBulk'][0])
    {
        return $this->closeChatsBulkAsyncWithHttpInfo($closeChatsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closeChatsBulkAsyncWithHttpInfo
     *
     * Close chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $closeChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeChatsBulkAsyncWithHttpInfo($closeChatsBulkInputObject, string $contentType = self::contentTypes['closeChatsBulk'][0])
    {
        $returnType = '';
        $request = $this->closeChatsBulkRequest($closeChatsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closeChatsBulk'
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $closeChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function closeChatsBulkRequest($closeChatsBulkInputObject, string $contentType = self::contentTypes['closeChatsBulk'][0])
    {

        // verify the required parameter 'closeChatsBulkInputObject' is set
        if ($closeChatsBulkInputObject === null || (is_array($closeChatsBulkInputObject) && count($closeChatsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $closeChatsBulkInputObject when calling closeChatsBulk'
            );
        }


        $resourcePath = '/api/v2/chats/close/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($closeChatsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($closeChatsBulkInputObject));
            } else {
                $httpBody = $closeChatsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation closeReadChats
     *
     * Close read chats
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeReadChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function closeReadChats(string $contentType = self::contentTypes['closeReadChats'][0])
    {
        $this->closeReadChatsWithHttpInfo($contentType);
    }

    /**
     * Operation closeReadChatsWithHttpInfo
     *
     * Close read chats
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeReadChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function closeReadChatsWithHttpInfo(string $contentType = self::contentTypes['closeReadChats'][0])
    {
        $request = $this->closeReadChatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation closeReadChatsAsync
     *
     * Close read chats
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeReadChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeReadChatsAsync(string $contentType = self::contentTypes['closeReadChats'][0])
    {
        return $this->closeReadChatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closeReadChatsAsyncWithHttpInfo
     *
     * Close read chats
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeReadChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeReadChatsAsyncWithHttpInfo(string $contentType = self::contentTypes['closeReadChats'][0])
    {
        $returnType = '';
        $request = $this->closeReadChatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closeReadChats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeReadChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function closeReadChatsRequest(string $contentType = self::contentTypes['closeReadChats'][0])
    {


        $resourcePath = '/api/v2/chats/close/read';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createContact
     *
     * Add a new contact
     *
     * @param  \TextMagic\Models\CreateContactRequest $createContactInputObject createContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function createContact($createContactInputObject, string $contentType = self::contentTypes['createContact'][0])
    {
        list($response) = $this->createContactWithHttpInfo($createContactInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createContactWithHttpInfo
     *
     * Add a new contact
     *
     * @param  \TextMagic\Models\CreateContactRequest $createContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactWithHttpInfo($createContactInputObject, string $contentType = self::contentTypes['createContact'][0])
    {
        $request = $this->createContactRequest($createContactInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createContactAsync
     *
     * Add a new contact
     *
     * @param  \TextMagic\Models\CreateContactRequest $createContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAsync($createContactInputObject, string $contentType = self::contentTypes['createContact'][0])
    {
        return $this->createContactAsyncWithHttpInfo($createContactInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactAsyncWithHttpInfo
     *
     * Add a new contact
     *
     * @param  \TextMagic\Models\CreateContactRequest $createContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAsyncWithHttpInfo($createContactInputObject, string $contentType = self::contentTypes['createContact'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->createContactRequest($createContactInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContact'
     *
     * @param  \TextMagic\Models\CreateContactRequest $createContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createContactRequest($createContactInputObject, string $contentType = self::contentTypes['createContact'][0])
    {

        // verify the required parameter 'createContactInputObject' is set
        if ($createContactInputObject === null || (is_array($createContactInputObject) && count($createContactInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createContactInputObject when calling createContact'
            );
        }


        $resourcePath = '/api/v2/contacts/normalized';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createContactInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createContactInputObject));
            } else {
                $httpBody = $createContactInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createContactNote
     *
     * Create a new contact note
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\CreateContactNoteRequest $createContactNoteInputObject createContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function createContactNote($id, $createContactNoteInputObject, string $contentType = self::contentTypes['createContactNote'][0])
    {
        list($response) = $this->createContactNoteWithHttpInfo($id, $createContactNoteInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createContactNoteWithHttpInfo
     *
     * Create a new contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateContactNoteRequest $createContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactNoteWithHttpInfo($id, $createContactNoteInputObject, string $contentType = self::contentTypes['createContactNote'][0])
    {
        $request = $this->createContactNoteRequest($id, $createContactNoteInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createContactNoteAsync
     *
     * Create a new contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateContactNoteRequest $createContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactNoteAsync($id, $createContactNoteInputObject, string $contentType = self::contentTypes['createContactNote'][0])
    {
        return $this->createContactNoteAsyncWithHttpInfo($id, $createContactNoteInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactNoteAsyncWithHttpInfo
     *
     * Create a new contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateContactNoteRequest $createContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactNoteAsyncWithHttpInfo($id, $createContactNoteInputObject, string $contentType = self::contentTypes['createContactNote'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->createContactNoteRequest($id, $createContactNoteInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactNote'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateContactNoteRequest $createContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createContactNoteRequest($id, $createContactNoteInputObject, string $contentType = self::contentTypes['createContactNote'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createContactNote'
            );
        }

        // verify the required parameter 'createContactNoteInputObject' is set
        if ($createContactNoteInputObject === null || (is_array($createContactNoteInputObject) && count($createContactNoteInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createContactNoteInputObject when calling createContactNote'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createContactNoteInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createContactNoteInputObject));
            } else {
                $httpBody = $createContactNoteInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCustomField
     *
     * Add a new custom field
     *
     * @param  \TextMagic\Models\CreateCustomFieldRequest $createCustomFieldInputObject createCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function createCustomField($createCustomFieldInputObject, string $contentType = self::contentTypes['createCustomField'][0])
    {
        list($response) = $this->createCustomFieldWithHttpInfo($createCustomFieldInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createCustomFieldWithHttpInfo
     *
     * Add a new custom field
     *
     * @param  \TextMagic\Models\CreateCustomFieldRequest $createCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCustomFieldWithHttpInfo($createCustomFieldInputObject, string $contentType = self::contentTypes['createCustomField'][0])
    {
        $request = $this->createCustomFieldRequest($createCustomFieldInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCustomFieldAsync
     *
     * Add a new custom field
     *
     * @param  \TextMagic\Models\CreateCustomFieldRequest $createCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomFieldAsync($createCustomFieldInputObject, string $contentType = self::contentTypes['createCustomField'][0])
    {
        return $this->createCustomFieldAsyncWithHttpInfo($createCustomFieldInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCustomFieldAsyncWithHttpInfo
     *
     * Add a new custom field
     *
     * @param  \TextMagic\Models\CreateCustomFieldRequest $createCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomFieldAsyncWithHttpInfo($createCustomFieldInputObject, string $contentType = self::contentTypes['createCustomField'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->createCustomFieldRequest($createCustomFieldInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCustomField'
     *
     * @param  \TextMagic\Models\CreateCustomFieldRequest $createCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCustomFieldRequest($createCustomFieldInputObject, string $contentType = self::contentTypes['createCustomField'][0])
    {

        // verify the required parameter 'createCustomFieldInputObject' is set
        if ($createCustomFieldInputObject === null || (is_array($createCustomFieldInputObject) && count($createCustomFieldInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCustomFieldInputObject when calling createCustomField'
            );
        }


        $resourcePath = '/api/v2/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createCustomFieldInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCustomFieldInputObject));
            } else {
                $httpBody = $createCustomFieldInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEmailCampaign
     *
     * Send email campaign
     *
     * @param  \TextMagic\Models\CreateEmailCampaignRequest $createEmailCampaignInputObject createEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmailCampaign'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\CreateEmailCampaignResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function createEmailCampaign($createEmailCampaignInputObject, string $contentType = self::contentTypes['createEmailCampaign'][0])
    {
        list($response) = $this->createEmailCampaignWithHttpInfo($createEmailCampaignInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createEmailCampaignWithHttpInfo
     *
     * Send email campaign
     *
     * @param  \TextMagic\Models\CreateEmailCampaignRequest $createEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmailCampaign'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\CreateEmailCampaignResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmailCampaignWithHttpInfo($createEmailCampaignInputObject, string $contentType = self::contentTypes['createEmailCampaign'][0])
    {
        $request = $this->createEmailCampaignRequest($createEmailCampaignInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\CreateEmailCampaignResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\CreateEmailCampaignResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\CreateEmailCampaignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEmailCampaignAsync
     *
     * Send email campaign
     *
     * @param  \TextMagic\Models\CreateEmailCampaignRequest $createEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailCampaignAsync($createEmailCampaignInputObject, string $contentType = self::contentTypes['createEmailCampaign'][0])
    {
        return $this->createEmailCampaignAsyncWithHttpInfo($createEmailCampaignInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmailCampaignAsyncWithHttpInfo
     *
     * Send email campaign
     *
     * @param  \TextMagic\Models\CreateEmailCampaignRequest $createEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmailCampaignAsyncWithHttpInfo($createEmailCampaignInputObject, string $contentType = self::contentTypes['createEmailCampaign'][0])
    {
        $returnType = '\TextMagic\Models\CreateEmailCampaignResponse';
        $request = $this->createEmailCampaignRequest($createEmailCampaignInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmailCampaign'
     *
     * @param  \TextMagic\Models\CreateEmailCampaignRequest $createEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEmailCampaignRequest($createEmailCampaignInputObject, string $contentType = self::contentTypes['createEmailCampaign'][0])
    {

        // verify the required parameter 'createEmailCampaignInputObject' is set
        if ($createEmailCampaignInputObject === null || (is_array($createEmailCampaignInputObject) && count($createEmailCampaignInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createEmailCampaignInputObject when calling createEmailCampaign'
            );
        }


        $resourcePath = '/api/v2/email-campaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createEmailCampaignInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createEmailCampaignInputObject));
            } else {
                $httpBody = $createEmailCampaignInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createList
     *
     * Create a new list
     *
     * @param  \TextMagic\Models\CreateListRequest $createListInputObject createListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function createList($createListInputObject, string $contentType = self::contentTypes['createList'][0])
    {
        list($response) = $this->createListWithHttpInfo($createListInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createListWithHttpInfo
     *
     * Create a new list
     *
     * @param  \TextMagic\Models\CreateListRequest $createListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createListWithHttpInfo($createListInputObject, string $contentType = self::contentTypes['createList'][0])
    {
        $request = $this->createListRequest($createListInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createListAsync
     *
     * Create a new list
     *
     * @param  \TextMagic\Models\CreateListRequest $createListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListAsync($createListInputObject, string $contentType = self::contentTypes['createList'][0])
    {
        return $this->createListAsyncWithHttpInfo($createListInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createListAsyncWithHttpInfo
     *
     * Create a new list
     *
     * @param  \TextMagic\Models\CreateListRequest $createListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListAsyncWithHttpInfo($createListInputObject, string $contentType = self::contentTypes['createList'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->createListRequest($createListInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createList'
     *
     * @param  \TextMagic\Models\CreateListRequest $createListInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createListRequest($createListInputObject, string $contentType = self::contentTypes['createList'][0])
    {

        // verify the required parameter 'createListInputObject' is set
        if ($createListInputObject === null || (is_array($createListInputObject) && count($createListInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createListInputObject when calling createList'
            );
        }


        $resourcePath = '/api/v2/lists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createListInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createListInputObject));
            } else {
                $httpBody = $createListInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTag
     *
     * Create tag
     *
     * @param  \TextMagic\Models\CreateTagRequest $createTagInputObject createTagInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\CreateTagResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function createTag($createTagInputObject, string $contentType = self::contentTypes['createTag'][0])
    {
        list($response) = $this->createTagWithHttpInfo($createTagInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createTagWithHttpInfo
     *
     * Create tag
     *
     * @param  \TextMagic\Models\CreateTagRequest $createTagInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\CreateTagResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTagWithHttpInfo($createTagInputObject, string $contentType = self::contentTypes['createTag'][0])
    {
        $request = $this->createTagRequest($createTagInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\CreateTagResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\CreateTagResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\CreateTagResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTagAsync
     *
     * Create tag
     *
     * @param  \TextMagic\Models\CreateTagRequest $createTagInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAsync($createTagInputObject, string $contentType = self::contentTypes['createTag'][0])
    {
        return $this->createTagAsyncWithHttpInfo($createTagInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTagAsyncWithHttpInfo
     *
     * Create tag
     *
     * @param  \TextMagic\Models\CreateTagRequest $createTagInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAsyncWithHttpInfo($createTagInputObject, string $contentType = self::contentTypes['createTag'][0])
    {
        $returnType = '\TextMagic\Models\CreateTagResponse';
        $request = $this->createTagRequest($createTagInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTag'
     *
     * @param  \TextMagic\Models\CreateTagRequest $createTagInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTagRequest($createTagInputObject, string $contentType = self::contentTypes['createTag'][0])
    {

        // verify the required parameter 'createTagInputObject' is set
        if ($createTagInputObject === null || (is_array($createTagInputObject) && count($createTagInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createTagInputObject when calling createTag'
            );
        }


        $resourcePath = '/api/v2/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createTagInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createTagInputObject));
            } else {
                $httpBody = $createTagInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTemplate
     *
     * Create a template
     *
     * @param  \TextMagic\Models\CreateTemplateRequest $createTemplateInputObject createTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function createTemplate($createTemplateInputObject, string $contentType = self::contentTypes['createTemplate'][0])
    {
        list($response) = $this->createTemplateWithHttpInfo($createTemplateInputObject, $contentType);
        return $response;
    }

    /**
     * Operation createTemplateWithHttpInfo
     *
     * Create a template
     *
     * @param  \TextMagic\Models\CreateTemplateRequest $createTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTemplateWithHttpInfo($createTemplateInputObject, string $contentType = self::contentTypes['createTemplate'][0])
    {
        $request = $this->createTemplateRequest($createTemplateInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTemplateAsync
     *
     * Create a template
     *
     * @param  \TextMagic\Models\CreateTemplateRequest $createTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateAsync($createTemplateInputObject, string $contentType = self::contentTypes['createTemplate'][0])
    {
        return $this->createTemplateAsyncWithHttpInfo($createTemplateInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTemplateAsyncWithHttpInfo
     *
     * Create a template
     *
     * @param  \TextMagic\Models\CreateTemplateRequest $createTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateAsyncWithHttpInfo($createTemplateInputObject, string $contentType = self::contentTypes['createTemplate'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->createTemplateRequest($createTemplateInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTemplate'
     *
     * @param  \TextMagic\Models\CreateTemplateRequest $createTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTemplateRequest($createTemplateInputObject, string $contentType = self::contentTypes['createTemplate'][0])
    {

        // verify the required parameter 'createTemplateInputObject' is set
        if ($createTemplateInputObject === null || (is_array($createTemplateInputObject) && count($createTemplateInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createTemplateInputObject when calling createTemplate'
            );
        }


        $resourcePath = '/api/v2/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createTemplateInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createTemplateInputObject));
            } else {
                $httpBody = $createTemplateInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllContacts
     *
     * Delete contacts (bulk)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllContacts(string $contentType = self::contentTypes['deleteAllContacts'][0])
    {
        $this->deleteAllContactsWithHttpInfo($contentType);
    }

    /**
     * Operation deleteAllContactsWithHttpInfo
     *
     * Delete contacts (bulk)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllContactsWithHttpInfo(string $contentType = self::contentTypes['deleteAllContacts'][0])
    {
        $request = $this->deleteAllContactsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAllContactsAsync
     *
     * Delete contacts (bulk)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllContactsAsync(string $contentType = self::contentTypes['deleteAllContacts'][0])
    {
        return $this->deleteAllContactsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllContactsAsyncWithHttpInfo
     *
     * Delete contacts (bulk)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllContactsAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteAllContacts'][0])
    {
        $returnType = '';
        $request = $this->deleteAllContactsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllContacts'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllContactsRequest(string $contentType = self::contentTypes['deleteAllContacts'][0])
    {


        $resourcePath = '/api/v2/contact/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllOutboundMessages
     *
     * Delete all messages
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllOutboundMessages(string $contentType = self::contentTypes['deleteAllOutboundMessages'][0])
    {
        $this->deleteAllOutboundMessagesWithHttpInfo($contentType);
    }

    /**
     * Operation deleteAllOutboundMessagesWithHttpInfo
     *
     * Delete all messages
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllOutboundMessagesWithHttpInfo(string $contentType = self::contentTypes['deleteAllOutboundMessages'][0])
    {
        $request = $this->deleteAllOutboundMessagesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAllOutboundMessagesAsync
     *
     * Delete all messages
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllOutboundMessagesAsync(string $contentType = self::contentTypes['deleteAllOutboundMessages'][0])
    {
        return $this->deleteAllOutboundMessagesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllOutboundMessagesAsyncWithHttpInfo
     *
     * Delete all messages
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllOutboundMessagesAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteAllOutboundMessages'][0])
    {
        $returnType = '';
        $request = $this->deleteAllOutboundMessagesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllOutboundMessages'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllOutboundMessagesRequest(string $contentType = self::contentTypes['deleteAllOutboundMessages'][0])
    {


        $resourcePath = '/api/v2/message/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAvatar
     *
     * Delete an avatar
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAvatar(string $contentType = self::contentTypes['deleteAvatar'][0])
    {
        $this->deleteAvatarWithHttpInfo($contentType);
    }

    /**
     * Operation deleteAvatarWithHttpInfo
     *
     * Delete an avatar
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAvatarWithHttpInfo(string $contentType = self::contentTypes['deleteAvatar'][0])
    {
        $request = $this->deleteAvatarRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAvatarAsync
     *
     * Delete an avatar
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAvatarAsync(string $contentType = self::contentTypes['deleteAvatar'][0])
    {
        return $this->deleteAvatarAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAvatarAsyncWithHttpInfo
     *
     * Delete an avatar
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAvatarAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteAvatar'][0])
    {
        $returnType = '';
        $request = $this->deleteAvatarRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAvatar'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAvatarRequest(string $contentType = self::contentTypes['deleteAvatar'][0])
    {


        $resourcePath = '/api/v2/user/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteChatMessages
     *
     * Delete chat messages by ID(s)
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\DeleteChatMessagesRequest $deleteChatMessagesBulkInputObject deleteChatMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteChatMessages($id, $deleteChatMessagesBulkInputObject, string $contentType = self::contentTypes['deleteChatMessages'][0])
    {
        $this->deleteChatMessagesWithHttpInfo($id, $deleteChatMessagesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteChatMessagesWithHttpInfo
     *
     * Delete chat messages by ID(s)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteChatMessagesRequest $deleteChatMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteChatMessagesWithHttpInfo($id, $deleteChatMessagesBulkInputObject, string $contentType = self::contentTypes['deleteChatMessages'][0])
    {
        $request = $this->deleteChatMessagesRequest($id, $deleteChatMessagesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteChatMessagesAsync
     *
     * Delete chat messages by ID(s)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteChatMessagesRequest $deleteChatMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteChatMessagesAsync($id, $deleteChatMessagesBulkInputObject, string $contentType = self::contentTypes['deleteChatMessages'][0])
    {
        return $this->deleteChatMessagesAsyncWithHttpInfo($id, $deleteChatMessagesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteChatMessagesAsyncWithHttpInfo
     *
     * Delete chat messages by ID(s)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteChatMessagesRequest $deleteChatMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteChatMessagesAsyncWithHttpInfo($id, $deleteChatMessagesBulkInputObject, string $contentType = self::contentTypes['deleteChatMessages'][0])
    {
        $returnType = '';
        $request = $this->deleteChatMessagesRequest($id, $deleteChatMessagesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteChatMessages'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteChatMessagesRequest $deleteChatMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteChatMessagesRequest($id, $deleteChatMessagesBulkInputObject, string $contentType = self::contentTypes['deleteChatMessages'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteChatMessages'
            );
        }

        // verify the required parameter 'deleteChatMessagesBulkInputObject' is set
        if ($deleteChatMessagesBulkInputObject === null || (is_array($deleteChatMessagesBulkInputObject) && count($deleteChatMessagesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteChatMessagesBulkInputObject when calling deleteChatMessages'
            );
        }


        $resourcePath = '/api/v2/chats/{id}/messages/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteChatMessagesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteChatMessagesBulkInputObject));
            } else {
                $httpBody = $deleteChatMessagesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteChatsBulk
     *
     * Delete chats (bulk)
     *
     * @param  \TextMagic\Models\DeleteChatsBulkRequest $deleteChatsBulkInputObject deleteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteChatsBulk($deleteChatsBulkInputObject, string $contentType = self::contentTypes['deleteChatsBulk'][0])
    {
        $this->deleteChatsBulkWithHttpInfo($deleteChatsBulkInputObject, $contentType);
    }

    /**
     * Operation deleteChatsBulkWithHttpInfo
     *
     * Delete chats (bulk)
     *
     * @param  \TextMagic\Models\DeleteChatsBulkRequest $deleteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteChatsBulkWithHttpInfo($deleteChatsBulkInputObject, string $contentType = self::contentTypes['deleteChatsBulk'][0])
    {
        $request = $this->deleteChatsBulkRequest($deleteChatsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteChatsBulkAsync
     *
     * Delete chats (bulk)
     *
     * @param  \TextMagic\Models\DeleteChatsBulkRequest $deleteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteChatsBulkAsync($deleteChatsBulkInputObject, string $contentType = self::contentTypes['deleteChatsBulk'][0])
    {
        return $this->deleteChatsBulkAsyncWithHttpInfo($deleteChatsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteChatsBulkAsyncWithHttpInfo
     *
     * Delete chats (bulk)
     *
     * @param  \TextMagic\Models\DeleteChatsBulkRequest $deleteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteChatsBulkAsyncWithHttpInfo($deleteChatsBulkInputObject, string $contentType = self::contentTypes['deleteChatsBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteChatsBulkRequest($deleteChatsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteChatsBulk'
     *
     * @param  \TextMagic\Models\DeleteChatsBulkRequest $deleteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteChatsBulkRequest($deleteChatsBulkInputObject, string $contentType = self::contentTypes['deleteChatsBulk'][0])
    {

        // verify the required parameter 'deleteChatsBulkInputObject' is set
        if ($deleteChatsBulkInputObject === null || (is_array($deleteChatsBulkInputObject) && count($deleteChatsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteChatsBulkInputObject when calling deleteChatsBulk'
            );
        }


        $resourcePath = '/api/v2/chats/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteChatsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteChatsBulkInputObject));
            } else {
                $httpBody = $deleteChatsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContact
     *
     * Delete a contact
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContact($id, string $contentType = self::contentTypes['deleteContact'][0])
    {
        $this->deleteContactWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteContactWithHttpInfo
     *
     * Delete a contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactWithHttpInfo($id, string $contentType = self::contentTypes['deleteContact'][0])
    {
        $request = $this->deleteContactRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactAsync
     *
     * Delete a contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactAsync($id, string $contentType = self::contentTypes['deleteContact'][0])
    {
        return $this->deleteContactAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactAsyncWithHttpInfo
     *
     * Delete a contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteContact'][0])
    {
        $returnType = '';
        $request = $this->deleteContactRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContact'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactRequest($id, string $contentType = self::contentTypes['deleteContact'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteContact'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactAvatar
     *
     * Delete an avatar
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactAvatar($id, string $contentType = self::contentTypes['deleteContactAvatar'][0])
    {
        $this->deleteContactAvatarWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteContactAvatarWithHttpInfo
     *
     * Delete an avatar
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactAvatarWithHttpInfo($id, string $contentType = self::contentTypes['deleteContactAvatar'][0])
    {
        $request = $this->deleteContactAvatarRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactAvatarAsync
     *
     * Delete an avatar
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactAvatarAsync($id, string $contentType = self::contentTypes['deleteContactAvatar'][0])
    {
        return $this->deleteContactAvatarAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactAvatarAsyncWithHttpInfo
     *
     * Delete an avatar
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactAvatarAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteContactAvatar'][0])
    {
        $returnType = '';
        $request = $this->deleteContactAvatarRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactAvatar'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactAvatarRequest($id, string $contentType = self::contentTypes['deleteContactAvatar'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteContactAvatar'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactNote
     *
     * Delete a contact note
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactNote($id, string $contentType = self::contentTypes['deleteContactNote'][0])
    {
        $this->deleteContactNoteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteContactNoteWithHttpInfo
     *
     * Delete a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactNoteWithHttpInfo($id, string $contentType = self::contentTypes['deleteContactNote'][0])
    {
        $request = $this->deleteContactNoteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactNoteAsync
     *
     * Delete a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactNoteAsync($id, string $contentType = self::contentTypes['deleteContactNote'][0])
    {
        return $this->deleteContactNoteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactNoteAsyncWithHttpInfo
     *
     * Delete a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactNoteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteContactNote'][0])
    {
        $returnType = '';
        $request = $this->deleteContactNoteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactNote'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactNoteRequest($id, string $contentType = self::contentTypes['deleteContactNote'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteContactNote'
            );
        }


        $resourcePath = '/api/v2/notes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactNotesBulk
     *
     * Delete contact notes (bulk)
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteContactNotesBulkInputObject deleteContactNotesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNotesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactNotesBulk($id, $deleteContactNotesBulkInputObject, string $contentType = self::contentTypes['deleteContactNotesBulk'][0])
    {
        $this->deleteContactNotesBulkWithHttpInfo($id, $deleteContactNotesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteContactNotesBulkWithHttpInfo
     *
     * Delete contact notes (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteContactNotesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNotesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactNotesBulkWithHttpInfo($id, $deleteContactNotesBulkInputObject, string $contentType = self::contentTypes['deleteContactNotesBulk'][0])
    {
        $request = $this->deleteContactNotesBulkRequest($id, $deleteContactNotesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactNotesBulkAsync
     *
     * Delete contact notes (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteContactNotesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNotesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactNotesBulkAsync($id, $deleteContactNotesBulkInputObject, string $contentType = self::contentTypes['deleteContactNotesBulk'][0])
    {
        return $this->deleteContactNotesBulkAsyncWithHttpInfo($id, $deleteContactNotesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactNotesBulkAsyncWithHttpInfo
     *
     * Delete contact notes (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteContactNotesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNotesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactNotesBulkAsyncWithHttpInfo($id, $deleteContactNotesBulkInputObject, string $contentType = self::contentTypes['deleteContactNotesBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteContactNotesBulkRequest($id, $deleteContactNotesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactNotesBulk'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteContactNotesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactNotesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactNotesBulkRequest($id, $deleteContactNotesBulkInputObject, string $contentType = self::contentTypes['deleteContactNotesBulk'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteContactNotesBulk'
            );
        }

        // verify the required parameter 'deleteContactNotesBulkInputObject' is set
        if ($deleteContactNotesBulkInputObject === null || (is_array($deleteContactNotesBulkInputObject) && count($deleteContactNotesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteContactNotesBulkInputObject when calling deleteContactNotesBulk'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}/notes/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteContactNotesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteContactNotesBulkInputObject));
            } else {
                $httpBody = $deleteContactNotesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactsByIds
     *
     * Delete contacts by IDs (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactsByIdsRequest $deleteContactsByIdsInputObject deleteContactsByIdsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsByIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactsByIds($deleteContactsByIdsInputObject, string $contentType = self::contentTypes['deleteContactsByIds'][0])
    {
        $this->deleteContactsByIdsWithHttpInfo($deleteContactsByIdsInputObject, $contentType);
    }

    /**
     * Operation deleteContactsByIdsWithHttpInfo
     *
     * Delete contacts by IDs (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactsByIdsRequest $deleteContactsByIdsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsByIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactsByIdsWithHttpInfo($deleteContactsByIdsInputObject, string $contentType = self::contentTypes['deleteContactsByIds'][0])
    {
        $request = $this->deleteContactsByIdsRequest($deleteContactsByIdsInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactsByIdsAsync
     *
     * Delete contacts by IDs (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactsByIdsRequest $deleteContactsByIdsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactsByIdsAsync($deleteContactsByIdsInputObject, string $contentType = self::contentTypes['deleteContactsByIds'][0])
    {
        return $this->deleteContactsByIdsAsyncWithHttpInfo($deleteContactsByIdsInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactsByIdsAsyncWithHttpInfo
     *
     * Delete contacts by IDs (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactsByIdsRequest $deleteContactsByIdsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactsByIdsAsyncWithHttpInfo($deleteContactsByIdsInputObject, string $contentType = self::contentTypes['deleteContactsByIds'][0])
    {
        $returnType = '';
        $request = $this->deleteContactsByIdsRequest($deleteContactsByIdsInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactsByIds'
     *
     * @param  \TextMagic\Models\DeleteContactsByIdsRequest $deleteContactsByIdsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactsByIdsRequest($deleteContactsByIdsInputObject, string $contentType = self::contentTypes['deleteContactsByIds'][0])
    {

        // verify the required parameter 'deleteContactsByIdsInputObject' is set
        if ($deleteContactsByIdsInputObject === null || (is_array($deleteContactsByIdsInputObject) && count($deleteContactsByIdsInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteContactsByIdsInputObject when calling deleteContactsByIds'
            );
        }


        $resourcePath = '/api/v2/contacts/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteContactsByIdsInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteContactsByIdsInputObject));
            } else {
                $httpBody = $deleteContactsByIdsInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactsFromList
     *
     * Unassign contacts from a list
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\DeleteContactsFromListRequest $deleteContacsFromListObject deleteContacsFromListObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsFromList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactsFromList($id, $deleteContacsFromListObject, string $contentType = self::contentTypes['deleteContactsFromList'][0])
    {
        $this->deleteContactsFromListWithHttpInfo($id, $deleteContacsFromListObject, $contentType);
    }

    /**
     * Operation deleteContactsFromListWithHttpInfo
     *
     * Unassign contacts from a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactsFromListRequest $deleteContacsFromListObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsFromList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactsFromListWithHttpInfo($id, $deleteContacsFromListObject, string $contentType = self::contentTypes['deleteContactsFromList'][0])
    {
        $request = $this->deleteContactsFromListRequest($id, $deleteContacsFromListObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteContactsFromListAsync
     *
     * Unassign contacts from a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactsFromListRequest $deleteContacsFromListObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsFromList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactsFromListAsync($id, $deleteContacsFromListObject, string $contentType = self::contentTypes['deleteContactsFromList'][0])
    {
        return $this->deleteContactsFromListAsyncWithHttpInfo($id, $deleteContacsFromListObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactsFromListAsyncWithHttpInfo
     *
     * Unassign contacts from a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactsFromListRequest $deleteContacsFromListObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsFromList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactsFromListAsyncWithHttpInfo($id, $deleteContacsFromListObject, string $contentType = self::contentTypes['deleteContactsFromList'][0])
    {
        $returnType = '';
        $request = $this->deleteContactsFromListRequest($id, $deleteContacsFromListObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactsFromList'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\DeleteContactsFromListRequest $deleteContacsFromListObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactsFromList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactsFromListRequest($id, $deleteContacsFromListObject, string $contentType = self::contentTypes['deleteContactsFromList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteContactsFromList'
            );
        }

        // verify the required parameter 'deleteContacsFromListObject' is set
        if ($deleteContacsFromListObject === null || (is_array($deleteContacsFromListObject) && count($deleteContacsFromListObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteContacsFromListObject when calling deleteContactsFromList'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteContacsFromListObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteContacsFromListObject));
            } else {
                $httpBody = $deleteContacsFromListObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomField
     *
     * Delete a custom field
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomField($id, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $this->deleteCustomFieldWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteCustomFieldWithHttpInfo
     *
     * Delete a custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomFieldWithHttpInfo($id, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $request = $this->deleteCustomFieldRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCustomFieldAsync
     *
     * Delete a custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomFieldAsync($id, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        return $this->deleteCustomFieldAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomFieldAsyncWithHttpInfo
     *
     * Delete a custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomFieldAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $returnType = '';
        $request = $this->deleteCustomFieldRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomField'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCustomFieldRequest($id, string $contentType = self::contentTypes['deleteCustomField'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteCustomField'
            );
        }


        $resourcePath = '/api/v2/customfields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDedicatedNumber
     *
     * Cancel a dedicated number subscription
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDedicatedNumber($id, string $contentType = self::contentTypes['deleteDedicatedNumber'][0])
    {
        $this->deleteDedicatedNumberWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteDedicatedNumberWithHttpInfo
     *
     * Cancel a dedicated number subscription
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDedicatedNumberWithHttpInfo($id, string $contentType = self::contentTypes['deleteDedicatedNumber'][0])
    {
        $request = $this->deleteDedicatedNumberRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteDedicatedNumberAsync
     *
     * Cancel a dedicated number subscription
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDedicatedNumberAsync($id, string $contentType = self::contentTypes['deleteDedicatedNumber'][0])
    {
        return $this->deleteDedicatedNumberAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDedicatedNumberAsyncWithHttpInfo
     *
     * Cancel a dedicated number subscription
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDedicatedNumberAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteDedicatedNumber'][0])
    {
        $returnType = '';
        $request = $this->deleteDedicatedNumberRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDedicatedNumber'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDedicatedNumberRequest($id, string $contentType = self::contentTypes['deleteDedicatedNumber'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDedicatedNumber'
            );
        }


        $resourcePath = '/api/v2/numbers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInboundMessage
     *
     * Delete a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInboundMessage($id, string $contentType = self::contentTypes['deleteInboundMessage'][0])
    {
        $this->deleteInboundMessageWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteInboundMessageWithHttpInfo
     *
     * Delete a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInboundMessageWithHttpInfo($id, string $contentType = self::contentTypes['deleteInboundMessage'][0])
    {
        $request = $this->deleteInboundMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteInboundMessageAsync
     *
     * Delete a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboundMessageAsync($id, string $contentType = self::contentTypes['deleteInboundMessage'][0])
    {
        return $this->deleteInboundMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInboundMessageAsyncWithHttpInfo
     *
     * Delete a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboundMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteInboundMessage'][0])
    {
        $returnType = '';
        $request = $this->deleteInboundMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInboundMessage'
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteInboundMessageRequest($id, string $contentType = self::contentTypes['deleteInboundMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInboundMessage'
            );
        }


        $resourcePath = '/api/v2/replies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInboundMessagesBulk
     *
     * Delete inbound messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteInboundMessagesBulkInputObject deleteInboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInboundMessagesBulk($deleteInboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteInboundMessagesBulk'][0])
    {
        $this->deleteInboundMessagesBulkWithHttpInfo($deleteInboundMessagesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteInboundMessagesBulkWithHttpInfo
     *
     * Delete inbound messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteInboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInboundMessagesBulkWithHttpInfo($deleteInboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteInboundMessagesBulk'][0])
    {
        $request = $this->deleteInboundMessagesBulkRequest($deleteInboundMessagesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteInboundMessagesBulkAsync
     *
     * Delete inbound messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteInboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboundMessagesBulkAsync($deleteInboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteInboundMessagesBulk'][0])
    {
        return $this->deleteInboundMessagesBulkAsyncWithHttpInfo($deleteInboundMessagesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInboundMessagesBulkAsyncWithHttpInfo
     *
     * Delete inbound messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteInboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboundMessagesBulkAsyncWithHttpInfo($deleteInboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteInboundMessagesBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteInboundMessagesBulkRequest($deleteInboundMessagesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInboundMessagesBulk'
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteInboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteInboundMessagesBulkRequest($deleteInboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteInboundMessagesBulk'][0])
    {

        // verify the required parameter 'deleteInboundMessagesBulkInputObject' is set
        if ($deleteInboundMessagesBulkInputObject === null || (is_array($deleteInboundMessagesBulkInputObject) && count($deleteInboundMessagesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteInboundMessagesBulkInputObject when calling deleteInboundMessagesBulk'
            );
        }


        $resourcePath = '/api/v2/replies/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteInboundMessagesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteInboundMessagesBulkInputObject));
            } else {
                $httpBody = $deleteInboundMessagesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteList
     *
     * Delete a list
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteList($id, string $contentType = self::contentTypes['deleteList'][0])
    {
        $this->deleteListWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteListWithHttpInfo
     *
     * Delete a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListWithHttpInfo($id, string $contentType = self::contentTypes['deleteList'][0])
    {
        $request = $this->deleteListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteListAsync
     *
     * Delete a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListAsync($id, string $contentType = self::contentTypes['deleteList'][0])
    {
        return $this->deleteListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListAsyncWithHttpInfo
     *
     * Delete a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteList'][0])
    {
        $returnType = '';
        $request = $this->deleteListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListRequest($id, string $contentType = self::contentTypes['deleteList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteList'
            );
        }


        $resourcePath = '/api/v2/lists/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteListAvatar
     *
     * Delete an avatar for a list
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteListAvatar($id, string $contentType = self::contentTypes['deleteListAvatar'][0])
    {
        $this->deleteListAvatarWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteListAvatarWithHttpInfo
     *
     * Delete an avatar for a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListAvatarWithHttpInfo($id, string $contentType = self::contentTypes['deleteListAvatar'][0])
    {
        $request = $this->deleteListAvatarRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteListAvatarAsync
     *
     * Delete an avatar for a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListAvatarAsync($id, string $contentType = self::contentTypes['deleteListAvatar'][0])
    {
        return $this->deleteListAvatarAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListAvatarAsyncWithHttpInfo
     *
     * Delete an avatar for a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListAvatarAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteListAvatar'][0])
    {
        $returnType = '';
        $request = $this->deleteListAvatarRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteListAvatar'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListAvatarRequest($id, string $contentType = self::contentTypes['deleteListAvatar'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteListAvatar'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteListContactsBulk
     *
     * Delete contacts from a list (bulk)
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $deleteListContactsBulkInputObject deleteListContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListContactsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteListContactsBulk($id, $deleteListContactsBulkInputObject, string $contentType = self::contentTypes['deleteListContactsBulk'][0])
    {
        $this->deleteListContactsBulkWithHttpInfo($id, $deleteListContactsBulkInputObject, $contentType);
    }

    /**
     * Operation deleteListContactsBulkWithHttpInfo
     *
     * Delete contacts from a list (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $deleteListContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListContactsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListContactsBulkWithHttpInfo($id, $deleteListContactsBulkInputObject, string $contentType = self::contentTypes['deleteListContactsBulk'][0])
    {
        $request = $this->deleteListContactsBulkRequest($id, $deleteListContactsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteListContactsBulkAsync
     *
     * Delete contacts from a list (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $deleteListContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListContactsBulkAsync($id, $deleteListContactsBulkInputObject, string $contentType = self::contentTypes['deleteListContactsBulk'][0])
    {
        return $this->deleteListContactsBulkAsyncWithHttpInfo($id, $deleteListContactsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListContactsBulkAsyncWithHttpInfo
     *
     * Delete contacts from a list (bulk)
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $deleteListContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListContactsBulkAsyncWithHttpInfo($id, $deleteListContactsBulkInputObject, string $contentType = self::contentTypes['deleteListContactsBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteListContactsBulkRequest($id, $deleteListContactsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteListContactsBulk'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $deleteListContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListContactsBulkRequest($id, $deleteListContactsBulkInputObject, string $contentType = self::contentTypes['deleteListContactsBulk'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteListContactsBulk'
            );
        }

        // verify the required parameter 'deleteListContactsBulkInputObject' is set
        if ($deleteListContactsBulkInputObject === null || (is_array($deleteListContactsBulkInputObject) && count($deleteListContactsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteListContactsBulkInputObject when calling deleteListContactsBulk'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/contacts/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteListContactsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteListContactsBulkInputObject));
            } else {
                $httpBody = $deleteListContactsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteListsBulk
     *
     * Delete lists (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteListsBulkInputObject deleteListsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteListsBulk($deleteListsBulkInputObject, string $contentType = self::contentTypes['deleteListsBulk'][0])
    {
        $this->deleteListsBulkWithHttpInfo($deleteListsBulkInputObject, $contentType);
    }

    /**
     * Operation deleteListsBulkWithHttpInfo
     *
     * Delete lists (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteListsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListsBulkWithHttpInfo($deleteListsBulkInputObject, string $contentType = self::contentTypes['deleteListsBulk'][0])
    {
        $request = $this->deleteListsBulkRequest($deleteListsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteListsBulkAsync
     *
     * Delete lists (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteListsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListsBulkAsync($deleteListsBulkInputObject, string $contentType = self::contentTypes['deleteListsBulk'][0])
    {
        return $this->deleteListsBulkAsyncWithHttpInfo($deleteListsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListsBulkAsyncWithHttpInfo
     *
     * Delete lists (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteListsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListsBulkAsyncWithHttpInfo($deleteListsBulkInputObject, string $contentType = self::contentTypes['deleteListsBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteListsBulkRequest($deleteListsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteListsBulk'
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteListsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListsBulkRequest($deleteListsBulkInputObject, string $contentType = self::contentTypes['deleteListsBulk'][0])
    {

        // verify the required parameter 'deleteListsBulkInputObject' is set
        if ($deleteListsBulkInputObject === null || (is_array($deleteListsBulkInputObject) && count($deleteListsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteListsBulkInputObject when calling deleteListsBulk'
            );
        }


        $resourcePath = '/api/v2/lists/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteListsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteListsBulkInputObject));
            } else {
                $httpBody = $deleteListsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMessageSession
     *
     * Delete a session
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMessageSession($id, string $contentType = self::contentTypes['deleteMessageSession'][0])
    {
        $this->deleteMessageSessionWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteMessageSessionWithHttpInfo
     *
     * Delete a session
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMessageSessionWithHttpInfo($id, string $contentType = self::contentTypes['deleteMessageSession'][0])
    {
        $request = $this->deleteMessageSessionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteMessageSessionAsync
     *
     * Delete a session
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMessageSessionAsync($id, string $contentType = self::contentTypes['deleteMessageSession'][0])
    {
        return $this->deleteMessageSessionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMessageSessionAsyncWithHttpInfo
     *
     * Delete a session
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMessageSessionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteMessageSession'][0])
    {
        $returnType = '';
        $request = $this->deleteMessageSessionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMessageSession'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMessageSessionRequest($id, string $contentType = self::contentTypes['deleteMessageSession'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteMessageSession'
            );
        }


        $resourcePath = '/api/v2/sessions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMessageSessionsBulk
     *
     * Delete sessions (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteMessageSessionsBulkInputObject deleteMessageSessionsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSessionsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMessageSessionsBulk($deleteMessageSessionsBulkInputObject, string $contentType = self::contentTypes['deleteMessageSessionsBulk'][0])
    {
        $this->deleteMessageSessionsBulkWithHttpInfo($deleteMessageSessionsBulkInputObject, $contentType);
    }

    /**
     * Operation deleteMessageSessionsBulkWithHttpInfo
     *
     * Delete sessions (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteMessageSessionsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSessionsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMessageSessionsBulkWithHttpInfo($deleteMessageSessionsBulkInputObject, string $contentType = self::contentTypes['deleteMessageSessionsBulk'][0])
    {
        $request = $this->deleteMessageSessionsBulkRequest($deleteMessageSessionsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteMessageSessionsBulkAsync
     *
     * Delete sessions (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteMessageSessionsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSessionsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMessageSessionsBulkAsync($deleteMessageSessionsBulkInputObject, string $contentType = self::contentTypes['deleteMessageSessionsBulk'][0])
    {
        return $this->deleteMessageSessionsBulkAsyncWithHttpInfo($deleteMessageSessionsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMessageSessionsBulkAsyncWithHttpInfo
     *
     * Delete sessions (bulk)
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteMessageSessionsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSessionsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMessageSessionsBulkAsyncWithHttpInfo($deleteMessageSessionsBulkInputObject, string $contentType = self::contentTypes['deleteMessageSessionsBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteMessageSessionsBulkRequest($deleteMessageSessionsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMessageSessionsBulk'
     *
     * @param  \TextMagic\Models\DeleteListsBulkRequest $deleteMessageSessionsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessageSessionsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMessageSessionsBulkRequest($deleteMessageSessionsBulkInputObject, string $contentType = self::contentTypes['deleteMessageSessionsBulk'][0])
    {

        // verify the required parameter 'deleteMessageSessionsBulkInputObject' is set
        if ($deleteMessageSessionsBulkInputObject === null || (is_array($deleteMessageSessionsBulkInputObject) && count($deleteMessageSessionsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteMessageSessionsBulkInputObject when calling deleteMessageSessionsBulk'
            );
        }


        $resourcePath = '/api/v2/sessions/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteMessageSessionsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteMessageSessionsBulkInputObject));
            } else {
                $httpBody = $deleteMessageSessionsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOutboundMessage
     *
     * Delete message
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOutboundMessage($id, string $contentType = self::contentTypes['deleteOutboundMessage'][0])
    {
        $this->deleteOutboundMessageWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteOutboundMessageWithHttpInfo
     *
     * Delete message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOutboundMessageWithHttpInfo($id, string $contentType = self::contentTypes['deleteOutboundMessage'][0])
    {
        $request = $this->deleteOutboundMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteOutboundMessageAsync
     *
     * Delete message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutboundMessageAsync($id, string $contentType = self::contentTypes['deleteOutboundMessage'][0])
    {
        return $this->deleteOutboundMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOutboundMessageAsyncWithHttpInfo
     *
     * Delete message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutboundMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteOutboundMessage'][0])
    {
        $returnType = '';
        $request = $this->deleteOutboundMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOutboundMessage'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOutboundMessageRequest($id, string $contentType = self::contentTypes['deleteOutboundMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteOutboundMessage'
            );
        }


        $resourcePath = '/api/v2/messages/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOutboundMessagesBulk
     *
     * Delete messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteOutboundMessagesBulkRequest $deleteOutboundMessagesBulkInputObject deleteOutboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOutboundMessagesBulk($deleteOutboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteOutboundMessagesBulk'][0])
    {
        $this->deleteOutboundMessagesBulkWithHttpInfo($deleteOutboundMessagesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteOutboundMessagesBulkWithHttpInfo
     *
     * Delete messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteOutboundMessagesBulkRequest $deleteOutboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOutboundMessagesBulkWithHttpInfo($deleteOutboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteOutboundMessagesBulk'][0])
    {
        $request = $this->deleteOutboundMessagesBulkRequest($deleteOutboundMessagesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteOutboundMessagesBulkAsync
     *
     * Delete messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteOutboundMessagesBulkRequest $deleteOutboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutboundMessagesBulkAsync($deleteOutboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteOutboundMessagesBulk'][0])
    {
        return $this->deleteOutboundMessagesBulkAsyncWithHttpInfo($deleteOutboundMessagesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOutboundMessagesBulkAsyncWithHttpInfo
     *
     * Delete messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteOutboundMessagesBulkRequest $deleteOutboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOutboundMessagesBulkAsyncWithHttpInfo($deleteOutboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteOutboundMessagesBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteOutboundMessagesBulkRequest($deleteOutboundMessagesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOutboundMessagesBulk'
     *
     * @param  \TextMagic\Models\DeleteOutboundMessagesBulkRequest $deleteOutboundMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOutboundMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOutboundMessagesBulkRequest($deleteOutboundMessagesBulkInputObject, string $contentType = self::contentTypes['deleteOutboundMessagesBulk'][0])
    {

        // verify the required parameter 'deleteOutboundMessagesBulkInputObject' is set
        if ($deleteOutboundMessagesBulkInputObject === null || (is_array($deleteOutboundMessagesBulkInputObject) && count($deleteOutboundMessagesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteOutboundMessagesBulkInputObject when calling deleteOutboundMessagesBulk'
            );
        }


        $resourcePath = '/api/v2/messages/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteOutboundMessagesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteOutboundMessagesBulkInputObject));
            } else {
                $httpBody = $deleteOutboundMessagesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteScheduledMessage
     *
     * Delete a single scheduled message
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteScheduledMessage($id, string $contentType = self::contentTypes['deleteScheduledMessage'][0])
    {
        $this->deleteScheduledMessageWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteScheduledMessageWithHttpInfo
     *
     * Delete a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteScheduledMessageWithHttpInfo($id, string $contentType = self::contentTypes['deleteScheduledMessage'][0])
    {
        $request = $this->deleteScheduledMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteScheduledMessageAsync
     *
     * Delete a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledMessageAsync($id, string $contentType = self::contentTypes['deleteScheduledMessage'][0])
    {
        return $this->deleteScheduledMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteScheduledMessageAsyncWithHttpInfo
     *
     * Delete a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteScheduledMessage'][0])
    {
        $returnType = '';
        $request = $this->deleteScheduledMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteScheduledMessage'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteScheduledMessageRequest($id, string $contentType = self::contentTypes['deleteScheduledMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteScheduledMessage'
            );
        }


        $resourcePath = '/api/v2/schedules/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteScheduledMessagesBulk
     *
     * Delete scheduled messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteScheduledMessagesBulkRequest $deleteScheduledMessagesBulkInputObject deleteScheduledMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteScheduledMessagesBulk($deleteScheduledMessagesBulkInputObject, string $contentType = self::contentTypes['deleteScheduledMessagesBulk'][0])
    {
        $this->deleteScheduledMessagesBulkWithHttpInfo($deleteScheduledMessagesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteScheduledMessagesBulkWithHttpInfo
     *
     * Delete scheduled messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteScheduledMessagesBulkRequest $deleteScheduledMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessagesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteScheduledMessagesBulkWithHttpInfo($deleteScheduledMessagesBulkInputObject, string $contentType = self::contentTypes['deleteScheduledMessagesBulk'][0])
    {
        $request = $this->deleteScheduledMessagesBulkRequest($deleteScheduledMessagesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteScheduledMessagesBulkAsync
     *
     * Delete scheduled messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteScheduledMessagesBulkRequest $deleteScheduledMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledMessagesBulkAsync($deleteScheduledMessagesBulkInputObject, string $contentType = self::contentTypes['deleteScheduledMessagesBulk'][0])
    {
        return $this->deleteScheduledMessagesBulkAsyncWithHttpInfo($deleteScheduledMessagesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteScheduledMessagesBulkAsyncWithHttpInfo
     *
     * Delete scheduled messages (bulk)
     *
     * @param  \TextMagic\Models\DeleteScheduledMessagesBulkRequest $deleteScheduledMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledMessagesBulkAsyncWithHttpInfo($deleteScheduledMessagesBulkInputObject, string $contentType = self::contentTypes['deleteScheduledMessagesBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteScheduledMessagesBulkRequest($deleteScheduledMessagesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteScheduledMessagesBulk'
     *
     * @param  \TextMagic\Models\DeleteScheduledMessagesBulkRequest $deleteScheduledMessagesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledMessagesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteScheduledMessagesBulkRequest($deleteScheduledMessagesBulkInputObject, string $contentType = self::contentTypes['deleteScheduledMessagesBulk'][0])
    {

        // verify the required parameter 'deleteScheduledMessagesBulkInputObject' is set
        if ($deleteScheduledMessagesBulkInputObject === null || (is_array($deleteScheduledMessagesBulkInputObject) && count($deleteScheduledMessagesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteScheduledMessagesBulkInputObject when calling deleteScheduledMessagesBulk'
            );
        }


        $resourcePath = '/api/v2/schedules/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteScheduledMessagesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteScheduledMessagesBulkInputObject));
            } else {
                $httpBody = $deleteScheduledMessagesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSenderId
     *
     * Delete a Sender ID
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSenderId($id, string $contentType = self::contentTypes['deleteSenderId'][0])
    {
        $this->deleteSenderIdWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteSenderIdWithHttpInfo
     *
     * Delete a Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSenderIdWithHttpInfo($id, string $contentType = self::contentTypes['deleteSenderId'][0])
    {
        $request = $this->deleteSenderIdRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSenderIdAsync
     *
     * Delete a Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSenderIdAsync($id, string $contentType = self::contentTypes['deleteSenderId'][0])
    {
        return $this->deleteSenderIdAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSenderIdAsyncWithHttpInfo
     *
     * Delete a Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSenderIdAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteSenderId'][0])
    {
        $returnType = '';
        $request = $this->deleteSenderIdRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSenderId'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSenderIdRequest($id, string $contentType = self::contentTypes['deleteSenderId'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteSenderId'
            );
        }


        $resourcePath = '/api/v2/senderids/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTemplate
     *
     * Delete a template
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTemplate($id, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        $this->deleteTemplateWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteTemplateWithHttpInfo
     *
     * Delete a template
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTemplateWithHttpInfo($id, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        $request = $this->deleteTemplateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTemplateAsync
     *
     * Delete a template
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsync($id, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        return $this->deleteTemplateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTemplateAsyncWithHttpInfo
     *
     * Delete a template
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        $returnType = '';
        $request = $this->deleteTemplateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTemplate'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTemplateRequest($id, string $contentType = self::contentTypes['deleteTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTemplate'
            );
        }


        $resourcePath = '/api/v2/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTemplatesBulk
     *
     * Delete templates (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteTemplatesBulkInputObject deleteTemplatesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplatesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTemplatesBulk($deleteTemplatesBulkInputObject, string $contentType = self::contentTypes['deleteTemplatesBulk'][0])
    {
        $this->deleteTemplatesBulkWithHttpInfo($deleteTemplatesBulkInputObject, $contentType);
    }

    /**
     * Operation deleteTemplatesBulkWithHttpInfo
     *
     * Delete templates (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteTemplatesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplatesBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTemplatesBulkWithHttpInfo($deleteTemplatesBulkInputObject, string $contentType = self::contentTypes['deleteTemplatesBulk'][0])
    {
        $request = $this->deleteTemplatesBulkRequest($deleteTemplatesBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTemplatesBulkAsync
     *
     * Delete templates (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteTemplatesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplatesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplatesBulkAsync($deleteTemplatesBulkInputObject, string $contentType = self::contentTypes['deleteTemplatesBulk'][0])
    {
        return $this->deleteTemplatesBulkAsyncWithHttpInfo($deleteTemplatesBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTemplatesBulkAsyncWithHttpInfo
     *
     * Delete templates (bulk)
     *
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteTemplatesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplatesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplatesBulkAsyncWithHttpInfo($deleteTemplatesBulkInputObject, string $contentType = self::contentTypes['deleteTemplatesBulk'][0])
    {
        $returnType = '';
        $request = $this->deleteTemplatesBulkRequest($deleteTemplatesBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTemplatesBulk'
     *
     * @param  \TextMagic\Models\DeleteContactNotesBulkRequest $deleteTemplatesBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplatesBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTemplatesBulkRequest($deleteTemplatesBulkInputObject, string $contentType = self::contentTypes['deleteTemplatesBulk'][0])
    {

        // verify the required parameter 'deleteTemplatesBulkInputObject' is set
        if ($deleteTemplatesBulkInputObject === null || (is_array($deleteTemplatesBulkInputObject) && count($deleteTemplatesBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteTemplatesBulkInputObject when calling deleteTemplatesBulk'
            );
        }


        $resourcePath = '/api/v2/templates/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteTemplatesBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteTemplatesBulkInputObject));
            } else {
                $httpBody = $deleteTemplatesBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation doCarrierLookup
     *
     * Carrier Lookup
     *
     * @param  string $phone Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers). (required)
     * @param  string|null $country This option must be specified only if the phone number is in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doCarrierLookup'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\DoCarrierLookupResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function doCarrierLookup($phone, $country = null, string $contentType = self::contentTypes['doCarrierLookup'][0])
    {
        list($response) = $this->doCarrierLookupWithHttpInfo($phone, $country, $contentType);
        return $response;
    }

    /**
     * Operation doCarrierLookupWithHttpInfo
     *
     * Carrier Lookup
     *
     * @param  string $phone Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers). (required)
     * @param  string|null $country This option must be specified only if the phone number is in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doCarrierLookup'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\DoCarrierLookupResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function doCarrierLookupWithHttpInfo($phone, $country = null, string $contentType = self::contentTypes['doCarrierLookup'][0])
    {
        $request = $this->doCarrierLookupRequest($phone, $country, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\DoCarrierLookupResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\DoCarrierLookupResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\DoCarrierLookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation doCarrierLookupAsync
     *
     * Carrier Lookup
     *
     * @param  string $phone Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers). (required)
     * @param  string|null $country This option must be specified only if the phone number is in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doCarrierLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doCarrierLookupAsync($phone, $country = null, string $contentType = self::contentTypes['doCarrierLookup'][0])
    {
        return $this->doCarrierLookupAsyncWithHttpInfo($phone, $country, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation doCarrierLookupAsyncWithHttpInfo
     *
     * Carrier Lookup
     *
     * @param  string $phone Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers). (required)
     * @param  string|null $country This option must be specified only if the phone number is in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doCarrierLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doCarrierLookupAsyncWithHttpInfo($phone, $country = null, string $contentType = self::contentTypes['doCarrierLookup'][0])
    {
        $returnType = '\TextMagic\Models\DoCarrierLookupResponse';
        $request = $this->doCarrierLookupRequest($phone, $country, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'doCarrierLookup'
     *
     * @param  string $phone Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers). (required)
     * @param  string|null $country This option must be specified only if the phone number is in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doCarrierLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function doCarrierLookupRequest($phone, $country = null, string $contentType = self::contentTypes['doCarrierLookup'][0])
    {

        // verify the required parameter 'phone' is set
        if ($phone === null || (is_array($phone) && count($phone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone when calling doCarrierLookup'
            );
        }



        $resourcePath = '/api/v2/lookups/{phone}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($phone !== null) {
            $resourcePath = str_replace(
                '{' . 'phone' . '}',
                ObjectSerializer::toPathValue($phone),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation doEmailLookup
     *
     * Email Lookup
     *
     * @param  string $email Email address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doEmailLookup'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\DoEmailLookupResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function doEmailLookup($email, string $contentType = self::contentTypes['doEmailLookup'][0])
    {
        list($response) = $this->doEmailLookupWithHttpInfo($email, $contentType);
        return $response;
    }

    /**
     * Operation doEmailLookupWithHttpInfo
     *
     * Email Lookup
     *
     * @param  string $email Email address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doEmailLookup'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\DoEmailLookupResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function doEmailLookupWithHttpInfo($email, string $contentType = self::contentTypes['doEmailLookup'][0])
    {
        $request = $this->doEmailLookupRequest($email, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\DoEmailLookupResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\DoEmailLookupResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\DoEmailLookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation doEmailLookupAsync
     *
     * Email Lookup
     *
     * @param  string $email Email address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doEmailLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doEmailLookupAsync($email, string $contentType = self::contentTypes['doEmailLookup'][0])
    {
        return $this->doEmailLookupAsyncWithHttpInfo($email, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation doEmailLookupAsyncWithHttpInfo
     *
     * Email Lookup
     *
     * @param  string $email Email address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doEmailLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doEmailLookupAsyncWithHttpInfo($email, string $contentType = self::contentTypes['doEmailLookup'][0])
    {
        $returnType = '\TextMagic\Models\DoEmailLookupResponse';
        $request = $this->doEmailLookupRequest($email, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'doEmailLookup'
     *
     * @param  string $email Email address. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['doEmailLookup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function doEmailLookupRequest($email, string $contentType = self::contentTypes['doEmailLookup'][0])
    {

        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling doEmailLookup'
            );
        }


        $resourcePath = '/api/v2/email-lookups/{email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($email !== null) {
            $resourcePath = str_replace(
                '{' . 'email' . '}',
                ObjectSerializer::toPathValue($email),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBulkSessions
     *
     * Get all bulk sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllBulkSessions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllBulkSessionsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllBulkSessions($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllBulkSessions'][0])
    {
        list($response) = $this->getAllBulkSessionsWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getAllBulkSessionsWithHttpInfo
     *
     * Get all bulk sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllBulkSessions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllBulkSessionsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBulkSessionsWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllBulkSessions'][0])
    {
        $request = $this->getAllBulkSessionsRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllBulkSessionsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllBulkSessionsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllBulkSessionsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllBulkSessionsAsync
     *
     * Get all bulk sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllBulkSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBulkSessionsAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllBulkSessions'][0])
    {
        return $this->getAllBulkSessionsAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBulkSessionsAsyncWithHttpInfo
     *
     * Get all bulk sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllBulkSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBulkSessionsAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllBulkSessions'][0])
    {
        $returnType = '\TextMagic\Models\GetAllBulkSessionsPaginatedResponse';
        $request = $this->getAllBulkSessionsRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBulkSessions'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllBulkSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllBulkSessionsRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllBulkSessions'][0])
    {




        $resourcePath = '/api/v2/bulks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllChats
     *
     * Get all chats
     *
     * @param  string|null $status Fetch only (a)ctive, (c)losed or (d)eleted chats. (optional)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $flat Should additional contact info be included? (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllChatsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllChats($status = null, $page = 1, $limit = 10, $orderBy = 'id', $voice = 0, $flat = 0, string $contentType = self::contentTypes['getAllChats'][0])
    {
        list($response) = $this->getAllChatsWithHttpInfo($status, $page, $limit, $orderBy, $voice, $flat, $contentType);
        return $response;
    }

    /**
     * Operation getAllChatsWithHttpInfo
     *
     * Get all chats
     *
     * @param  string|null $status Fetch only (a)ctive, (c)losed or (d)eleted chats. (optional)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $flat Should additional contact info be included? (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllChatsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllChatsWithHttpInfo($status = null, $page = 1, $limit = 10, $orderBy = 'id', $voice = 0, $flat = 0, string $contentType = self::contentTypes['getAllChats'][0])
    {
        $request = $this->getAllChatsRequest($status, $page, $limit, $orderBy, $voice, $flat, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllChatsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllChatsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllChatsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllChatsAsync
     *
     * Get all chats
     *
     * @param  string|null $status Fetch only (a)ctive, (c)losed or (d)eleted chats. (optional)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $flat Should additional contact info be included? (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllChatsAsync($status = null, $page = 1, $limit = 10, $orderBy = 'id', $voice = 0, $flat = 0, string $contentType = self::contentTypes['getAllChats'][0])
    {
        return $this->getAllChatsAsyncWithHttpInfo($status, $page, $limit, $orderBy, $voice, $flat, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllChatsAsyncWithHttpInfo
     *
     * Get all chats
     *
     * @param  string|null $status Fetch only (a)ctive, (c)losed or (d)eleted chats. (optional)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $flat Should additional contact info be included? (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllChatsAsyncWithHttpInfo($status = null, $page = 1, $limit = 10, $orderBy = 'id', $voice = 0, $flat = 0, string $contentType = self::contentTypes['getAllChats'][0])
    {
        $returnType = '\TextMagic\Models\GetAllChatsPaginatedResponse';
        $request = $this->getAllChatsRequest($status, $page, $limit, $orderBy, $voice, $flat, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllChats'
     *
     * @param  string|null $status Fetch only (a)ctive, (c)losed or (d)eleted chats. (optional)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $flat Should additional contact info be included? (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllChatsRequest($status = null, $page = 1, $limit = 10, $orderBy = 'id', $voice = 0, $flat = 0, string $contentType = self::contentTypes['getAllChats'][0])
    {








        $resourcePath = '/api/v2/chats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voice,
            'voice', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flat,
            'flat', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllInboundMessages
     *
     * Get all inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllInboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllInboundMessagesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllInboundMessages($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllInboundMessages'][0])
    {
        list($response) = $this->getAllInboundMessagesWithHttpInfo($page, $limit, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getAllInboundMessagesWithHttpInfo
     *
     * Get all inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllInboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllInboundMessagesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllInboundMessagesWithHttpInfo($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllInboundMessages'][0])
    {
        $request = $this->getAllInboundMessagesRequest($page, $limit, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllInboundMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllInboundMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllInboundMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllInboundMessagesAsync
     *
     * Get all inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllInboundMessagesAsync($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllInboundMessages'][0])
    {
        return $this->getAllInboundMessagesAsyncWithHttpInfo($page, $limit, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllInboundMessagesAsyncWithHttpInfo
     *
     * Get all inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllInboundMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllInboundMessages'][0])
    {
        $returnType = '\TextMagic\Models\GetAllInboundMessagesPaginatedResponse';
        $request = $this->getAllInboundMessagesRequest($page, $limit, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllInboundMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllInboundMessagesRequest($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllInboundMessages'][0])
    {






        $resourcePath = '/api/v2/replies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllMessageSessions
     *
     * Get all sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllMessageSessions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllMessageSessionsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllMessageSessions($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllMessageSessions'][0])
    {
        list($response) = $this->getAllMessageSessionsWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getAllMessageSessionsWithHttpInfo
     *
     * Get all sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllMessageSessions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllMessageSessionsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllMessageSessionsWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllMessageSessions'][0])
    {
        $request = $this->getAllMessageSessionsRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllMessageSessionsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllMessageSessionsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllMessageSessionsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllMessageSessionsAsync
     *
     * Get all sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllMessageSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllMessageSessionsAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllMessageSessions'][0])
    {
        return $this->getAllMessageSessionsAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllMessageSessionsAsyncWithHttpInfo
     *
     * Get all sessions
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllMessageSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllMessageSessionsAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllMessageSessions'][0])
    {
        $returnType = '\TextMagic\Models\GetAllMessageSessionsPaginatedResponse';
        $request = $this->getAllMessageSessionsRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllMessageSessions'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllMessageSessions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllMessageSessionsRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getAllMessageSessions'][0])
    {




        $resourcePath = '/api/v2/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllOutboundMessages
     *
     * Get all messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllOutboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllOutboundMessages($page = 1, $limit = 10, $lastId = null, string $contentType = self::contentTypes['getAllOutboundMessages'][0])
    {
        list($response) = $this->getAllOutboundMessagesWithHttpInfo($page, $limit, $lastId, $contentType);
        return $response;
    }

    /**
     * Operation getAllOutboundMessagesWithHttpInfo
     *
     * Get all messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllOutboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllOutboundMessagesWithHttpInfo($page = 1, $limit = 10, $lastId = null, string $contentType = self::contentTypes['getAllOutboundMessages'][0])
    {
        $request = $this->getAllOutboundMessagesRequest($page, $limit, $lastId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllOutboundMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllOutboundMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllOutboundMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllOutboundMessagesAsync
     *
     * Get all messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOutboundMessagesAsync($page = 1, $limit = 10, $lastId = null, string $contentType = self::contentTypes['getAllOutboundMessages'][0])
    {
        return $this->getAllOutboundMessagesAsyncWithHttpInfo($page, $limit, $lastId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllOutboundMessagesAsyncWithHttpInfo
     *
     * Get all messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOutboundMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $lastId = null, string $contentType = self::contentTypes['getAllOutboundMessages'][0])
    {
        $returnType = '\TextMagic\Models\GetAllOutboundMessagesPaginatedResponse';
        $request = $this->getAllOutboundMessagesRequest($page, $limit, $lastId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllOutboundMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllOutboundMessagesRequest($page = 1, $limit = 10, $lastId = null, string $contentType = self::contentTypes['getAllOutboundMessages'][0])
    {





        $resourcePath = '/api/v2/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastId,
            'lastId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllScheduledMessages
     *
     * Get all scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllScheduledMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllScheduledMessagesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllScheduledMessages($page = 1, $limit = 10, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllScheduledMessages'][0])
    {
        list($response) = $this->getAllScheduledMessagesWithHttpInfo($page, $limit, $status, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getAllScheduledMessagesWithHttpInfo
     *
     * Get all scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllScheduledMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllScheduledMessagesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllScheduledMessagesWithHttpInfo($page = 1, $limit = 10, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllScheduledMessages'][0])
    {
        $request = $this->getAllScheduledMessagesRequest($page, $limit, $status, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllScheduledMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllScheduledMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllScheduledMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllScheduledMessagesAsync
     *
     * Get all scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllScheduledMessagesAsync($page = 1, $limit = 10, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllScheduledMessages'][0])
    {
        return $this->getAllScheduledMessagesAsyncWithHttpInfo($page, $limit, $status, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllScheduledMessagesAsyncWithHttpInfo
     *
     * Get all scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllScheduledMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllScheduledMessages'][0])
    {
        $returnType = '\TextMagic\Models\GetAllScheduledMessagesPaginatedResponse';
        $request = $this->getAllScheduledMessagesRequest($page, $limit, $status, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllScheduledMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllScheduledMessagesRequest($page = 1, $limit = 10, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getAllScheduledMessages'][0])
    {







        $resourcePath = '/api/v2/schedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllTemplates
     *
     * Get all templates
     *
     * @param  int|null $page Fetch specified results page. (optional)
     * @param  int|null $limit The number of results per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllTemplates'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAllTemplatesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAllTemplates($page = null, $limit = null, string $contentType = self::contentTypes['getAllTemplates'][0])
    {
        list($response) = $this->getAllTemplatesWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getAllTemplatesWithHttpInfo
     *
     * Get all templates
     *
     * @param  int|null $page Fetch specified results page. (optional)
     * @param  int|null $limit The number of results per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllTemplates'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAllTemplatesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllTemplatesWithHttpInfo($page = null, $limit = null, string $contentType = self::contentTypes['getAllTemplates'][0])
    {
        $request = $this->getAllTemplatesRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAllTemplatesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAllTemplatesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAllTemplatesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllTemplatesAsync
     *
     * Get all templates
     *
     * @param  int|null $page Fetch specified results page. (optional)
     * @param  int|null $limit The number of results per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTemplatesAsync($page = null, $limit = null, string $contentType = self::contentTypes['getAllTemplates'][0])
    {
        return $this->getAllTemplatesAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllTemplatesAsyncWithHttpInfo
     *
     * Get all templates
     *
     * @param  int|null $page Fetch specified results page. (optional)
     * @param  int|null $limit The number of results per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTemplatesAsyncWithHttpInfo($page = null, $limit = null, string $contentType = self::contentTypes['getAllTemplates'][0])
    {
        $returnType = '\TextMagic\Models\GetAllTemplatesPaginatedResponse';
        $request = $this->getAllTemplatesRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllTemplates'
     *
     * @param  int|null $page Fetch specified results page. (optional)
     * @param  int|null $limit The number of results per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllTemplatesRequest($page = null, $limit = null, string $contentType = self::contentTypes['getAllTemplates'][0])
    {




        $resourcePath = '/api/v2/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAvailableDedicatedNumbers
     *
     * Find dedicated numbers available for purchase
     *
     * @param  string $country The 2-letter dedicated number country ISO code. (required)
     * @param  int|null $prefix Desired number prefix. Should include the country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country. (optional)
     * @param  int|null $tollfree Should we show only tollfree numbers (tollfree available only for US). (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAvailableDedicatedNumbersResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getAvailableDedicatedNumbers($country, $prefix = null, $tollfree = 0, string $contentType = self::contentTypes['getAvailableDedicatedNumbers'][0])
    {
        list($response) = $this->getAvailableDedicatedNumbersWithHttpInfo($country, $prefix, $tollfree, $contentType);
        return $response;
    }

    /**
     * Operation getAvailableDedicatedNumbersWithHttpInfo
     *
     * Find dedicated numbers available for purchase
     *
     * @param  string $country The 2-letter dedicated number country ISO code. (required)
     * @param  int|null $prefix Desired number prefix. Should include the country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country. (optional)
     * @param  int|null $tollfree Should we show only tollfree numbers (tollfree available only for US). (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAvailableDedicatedNumbersResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAvailableDedicatedNumbersWithHttpInfo($country, $prefix = null, $tollfree = 0, string $contentType = self::contentTypes['getAvailableDedicatedNumbers'][0])
    {
        $request = $this->getAvailableDedicatedNumbersRequest($country, $prefix, $tollfree, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAvailableDedicatedNumbersResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAvailableDedicatedNumbersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAvailableDedicatedNumbersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAvailableDedicatedNumbersAsync
     *
     * Find dedicated numbers available for purchase
     *
     * @param  string $country The 2-letter dedicated number country ISO code. (required)
     * @param  int|null $prefix Desired number prefix. Should include the country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country. (optional)
     * @param  int|null $tollfree Should we show only tollfree numbers (tollfree available only for US). (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailableDedicatedNumbersAsync($country, $prefix = null, $tollfree = 0, string $contentType = self::contentTypes['getAvailableDedicatedNumbers'][0])
    {
        return $this->getAvailableDedicatedNumbersAsyncWithHttpInfo($country, $prefix, $tollfree, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAvailableDedicatedNumbersAsyncWithHttpInfo
     *
     * Find dedicated numbers available for purchase
     *
     * @param  string $country The 2-letter dedicated number country ISO code. (required)
     * @param  int|null $prefix Desired number prefix. Should include the country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country. (optional)
     * @param  int|null $tollfree Should we show only tollfree numbers (tollfree available only for US). (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailableDedicatedNumbersAsyncWithHttpInfo($country, $prefix = null, $tollfree = 0, string $contentType = self::contentTypes['getAvailableDedicatedNumbers'][0])
    {
        $returnType = '\TextMagic\Models\GetAvailableDedicatedNumbersResponse';
        $request = $this->getAvailableDedicatedNumbersRequest($country, $prefix, $tollfree, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAvailableDedicatedNumbers'
     *
     * @param  string $country The 2-letter dedicated number country ISO code. (required)
     * @param  int|null $prefix Desired number prefix. Should include the country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country. (optional)
     * @param  int|null $tollfree Should we show only tollfree numbers (tollfree available only for US). (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAvailableDedicatedNumbersRequest($country, $prefix = null, $tollfree = 0, string $contentType = self::contentTypes['getAvailableDedicatedNumbers'][0])
    {

        // verify the required parameter 'country' is set
        if ($country === null || (is_array($country) && count($country) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country when calling getAvailableDedicatedNumbers'
            );
        }




        $resourcePath = '/api/v2/numbers/available';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefix,
            'prefix', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tollfree,
            'tollfree', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAvailableSenderSettingOptions
     *
     * Get available sender settings
     *
     * @param  string|null $country The 2-letter ISO country ID. If not specified, it returns all the available sender settings. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableSenderSettingOptions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetAvailableSenderSettingOptionsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getAvailableSenderSettingOptions($country = null, string $contentType = self::contentTypes['getAvailableSenderSettingOptions'][0])
    {
        list($response) = $this->getAvailableSenderSettingOptionsWithHttpInfo($country, $contentType);
        return $response;
    }

    /**
     * Operation getAvailableSenderSettingOptionsWithHttpInfo
     *
     * Get available sender settings
     *
     * @param  string|null $country The 2-letter ISO country ID. If not specified, it returns all the available sender settings. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableSenderSettingOptions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetAvailableSenderSettingOptionsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAvailableSenderSettingOptionsWithHttpInfo($country = null, string $contentType = self::contentTypes['getAvailableSenderSettingOptions'][0])
    {
        $request = $this->getAvailableSenderSettingOptionsRequest($country, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetAvailableSenderSettingOptionsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetAvailableSenderSettingOptionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetAvailableSenderSettingOptionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAvailableSenderSettingOptionsAsync
     *
     * Get available sender settings
     *
     * @param  string|null $country The 2-letter ISO country ID. If not specified, it returns all the available sender settings. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableSenderSettingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailableSenderSettingOptionsAsync($country = null, string $contentType = self::contentTypes['getAvailableSenderSettingOptions'][0])
    {
        return $this->getAvailableSenderSettingOptionsAsyncWithHttpInfo($country, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAvailableSenderSettingOptionsAsyncWithHttpInfo
     *
     * Get available sender settings
     *
     * @param  string|null $country The 2-letter ISO country ID. If not specified, it returns all the available sender settings. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableSenderSettingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailableSenderSettingOptionsAsyncWithHttpInfo($country = null, string $contentType = self::contentTypes['getAvailableSenderSettingOptions'][0])
    {
        $returnType = '\TextMagic\Models\GetAvailableSenderSettingOptionsResponse';
        $request = $this->getAvailableSenderSettingOptionsRequest($country, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAvailableSenderSettingOptions'
     *
     * @param  string|null $country The 2-letter ISO country ID. If not specified, it returns all the available sender settings. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailableSenderSettingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAvailableSenderSettingOptionsRequest($country = null, string $contentType = self::contentTypes['getAvailableSenderSettingOptions'][0])
    {



        $resourcePath = '/api/v2/sources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceNotificationOptions
     *
     * Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationOptions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetBalanceNotificationOptionsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getBalanceNotificationOptions(string $contentType = self::contentTypes['getBalanceNotificationOptions'][0])
    {
        list($response) = $this->getBalanceNotificationOptionsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBalanceNotificationOptionsWithHttpInfo
     *
     * Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationOptions'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetBalanceNotificationOptionsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceNotificationOptionsWithHttpInfo(string $contentType = self::contentTypes['getBalanceNotificationOptions'][0])
    {
        $request = $this->getBalanceNotificationOptionsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetBalanceNotificationOptionsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetBalanceNotificationOptionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetBalanceNotificationOptionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalanceNotificationOptionsAsync
     *
     * Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationOptionsAsync(string $contentType = self::contentTypes['getBalanceNotificationOptions'][0])
    {
        return $this->getBalanceNotificationOptionsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceNotificationOptionsAsyncWithHttpInfo
     *
     * Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationOptionsAsyncWithHttpInfo(string $contentType = self::contentTypes['getBalanceNotificationOptions'][0])
    {
        $returnType = '\TextMagic\Models\GetBalanceNotificationOptionsResponse';
        $request = $this->getBalanceNotificationOptionsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceNotificationOptions'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalanceNotificationOptionsRequest(string $contentType = self::contentTypes['getBalanceNotificationOptions'][0])
    {


        $resourcePath = '/api/v2/user/notification/balance/bundles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceNotificationSettings
     *
     * Get balance notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetBalanceNotificationSettingsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getBalanceNotificationSettings(string $contentType = self::contentTypes['getBalanceNotificationSettings'][0])
    {
        list($response) = $this->getBalanceNotificationSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBalanceNotificationSettingsWithHttpInfo
     *
     * Get balance notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetBalanceNotificationSettingsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceNotificationSettingsWithHttpInfo(string $contentType = self::contentTypes['getBalanceNotificationSettings'][0])
    {
        $request = $this->getBalanceNotificationSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetBalanceNotificationSettingsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetBalanceNotificationSettingsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetBalanceNotificationSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalanceNotificationSettingsAsync
     *
     * Get balance notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationSettingsAsync(string $contentType = self::contentTypes['getBalanceNotificationSettings'][0])
    {
        return $this->getBalanceNotificationSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceNotificationSettingsAsyncWithHttpInfo
     *
     * Get balance notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceNotificationSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getBalanceNotificationSettings'][0])
    {
        $returnType = '\TextMagic\Models\GetBalanceNotificationSettingsResponse';
        $request = $this->getBalanceNotificationSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceNotificationSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalanceNotificationSettingsRequest(string $contentType = self::contentTypes['getBalanceNotificationSettings'][0])
    {


        $resourcePath = '/api/v2/user/notification/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBlockedContacts
     *
     * Get blocked contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find blocked contacts by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBlockedContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetBlockedContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getBlockedContacts($page = 1, $limit = 10, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getBlockedContacts'][0])
    {
        list($response) = $this->getBlockedContactsWithHttpInfo($page, $limit, $query, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getBlockedContactsWithHttpInfo
     *
     * Get blocked contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find blocked contacts by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBlockedContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetBlockedContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBlockedContactsWithHttpInfo($page = 1, $limit = 10, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getBlockedContacts'][0])
    {
        $request = $this->getBlockedContactsRequest($page, $limit, $query, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetBlockedContactsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetBlockedContactsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetBlockedContactsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBlockedContactsAsync
     *
     * Get blocked contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find blocked contacts by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBlockedContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockedContactsAsync($page = 1, $limit = 10, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getBlockedContacts'][0])
    {
        return $this->getBlockedContactsAsyncWithHttpInfo($page, $limit, $query, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBlockedContactsAsyncWithHttpInfo
     *
     * Get blocked contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find blocked contacts by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBlockedContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockedContactsAsyncWithHttpInfo($page = 1, $limit = 10, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getBlockedContacts'][0])
    {
        $returnType = '\TextMagic\Models\GetBlockedContactsPaginatedResponse';
        $request = $this->getBlockedContactsRequest($page, $limit, $query, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBlockedContacts'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find blocked contacts by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBlockedContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBlockedContactsRequest($page = 1, $limit = 10, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getBlockedContacts'][0])
    {







        $resourcePath = '/api/v2/contacts/block/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBulkSession
     *
     * Get bulk session status
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBulkSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\BulkSession|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getBulkSession($id, string $contentType = self::contentTypes['getBulkSession'][0])
    {
        list($response) = $this->getBulkSessionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getBulkSessionWithHttpInfo
     *
     * Get bulk session status
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBulkSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\BulkSession|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBulkSessionWithHttpInfo($id, string $contentType = self::contentTypes['getBulkSession'][0])
    {
        $request = $this->getBulkSessionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BulkSession',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\BulkSession',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BulkSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBulkSessionAsync
     *
     * Get bulk session status
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBulkSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBulkSessionAsync($id, string $contentType = self::contentTypes['getBulkSession'][0])
    {
        return $this->getBulkSessionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBulkSessionAsyncWithHttpInfo
     *
     * Get bulk session status
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBulkSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBulkSessionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getBulkSession'][0])
    {
        $returnType = '\TextMagic\Models\BulkSession';
        $request = $this->getBulkSessionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBulkSession'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBulkSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBulkSessionRequest($id, string $contentType = self::contentTypes['getBulkSession'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBulkSession'
            );
        }


        $resourcePath = '/api/v2/bulks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCallbackSettings
     *
     * Fetch callback URL settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCallbackSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetCallbackSettingsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getCallbackSettings(string $contentType = self::contentTypes['getCallbackSettings'][0])
    {
        list($response) = $this->getCallbackSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getCallbackSettingsWithHttpInfo
     *
     * Fetch callback URL settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCallbackSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetCallbackSettingsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCallbackSettingsWithHttpInfo(string $contentType = self::contentTypes['getCallbackSettings'][0])
    {
        $request = $this->getCallbackSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetCallbackSettingsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetCallbackSettingsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetCallbackSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCallbackSettingsAsync
     *
     * Fetch callback URL settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallbackSettingsAsync(string $contentType = self::contentTypes['getCallbackSettings'][0])
    {
        return $this->getCallbackSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCallbackSettingsAsyncWithHttpInfo
     *
     * Fetch callback URL settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCallbackSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getCallbackSettings'][0])
    {
        $returnType = '\TextMagic\Models\GetCallbackSettingsResponse';
        $request = $this->getCallbackSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCallbackSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCallbackSettingsRequest(string $contentType = self::contentTypes['getCallbackSettings'][0])
    {


        $resourcePath = '/api/v2/callback/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChat
     *
     * Get a single chat
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\Chat|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getChat($id, string $contentType = self::contentTypes['getChat'][0])
    {
        list($response) = $this->getChatWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getChatWithHttpInfo
     *
     * Get a single chat
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\Chat|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChatWithHttpInfo($id, string $contentType = self::contentTypes['getChat'][0])
    {
        $request = $this->getChatRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\Chat',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\Chat',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\Chat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getChatAsync
     *
     * Get a single chat
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatAsync($id, string $contentType = self::contentTypes['getChat'][0])
    {
        return $this->getChatAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChatAsyncWithHttpInfo
     *
     * Get a single chat
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getChat'][0])
    {
        $returnType = '\TextMagic\Models\Chat';
        $request = $this->getChatRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChat'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChatRequest($id, string $contentType = self::contentTypes['getChat'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getChat'
            );
        }


        $resourcePath = '/api/v2/chats/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChatByPhone
     *
     * Find chats by phone
     *
     * @param  string $phone phone (required)
     * @param  int|null $upsert Create a new chat if not found. (optional, default to 0)
     * @param  int|null $reopen Reopen chat if found or do not change status. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatByPhone'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\Chat|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getChatByPhone($phone, $upsert = 0, $reopen = 0, string $contentType = self::contentTypes['getChatByPhone'][0])
    {
        list($response) = $this->getChatByPhoneWithHttpInfo($phone, $upsert, $reopen, $contentType);
        return $response;
    }

    /**
     * Operation getChatByPhoneWithHttpInfo
     *
     * Find chats by phone
     *
     * @param  string $phone (required)
     * @param  int|null $upsert Create a new chat if not found. (optional, default to 0)
     * @param  int|null $reopen Reopen chat if found or do not change status. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatByPhone'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\Chat|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChatByPhoneWithHttpInfo($phone, $upsert = 0, $reopen = 0, string $contentType = self::contentTypes['getChatByPhone'][0])
    {
        $request = $this->getChatByPhoneRequest($phone, $upsert, $reopen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\Chat',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\Chat',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\Chat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getChatByPhoneAsync
     *
     * Find chats by phone
     *
     * @param  string $phone (required)
     * @param  int|null $upsert Create a new chat if not found. (optional, default to 0)
     * @param  int|null $reopen Reopen chat if found or do not change status. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatByPhoneAsync($phone, $upsert = 0, $reopen = 0, string $contentType = self::contentTypes['getChatByPhone'][0])
    {
        return $this->getChatByPhoneAsyncWithHttpInfo($phone, $upsert, $reopen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChatByPhoneAsyncWithHttpInfo
     *
     * Find chats by phone
     *
     * @param  string $phone (required)
     * @param  int|null $upsert Create a new chat if not found. (optional, default to 0)
     * @param  int|null $reopen Reopen chat if found or do not change status. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatByPhoneAsyncWithHttpInfo($phone, $upsert = 0, $reopen = 0, string $contentType = self::contentTypes['getChatByPhone'][0])
    {
        $returnType = '\TextMagic\Models\Chat';
        $request = $this->getChatByPhoneRequest($phone, $upsert, $reopen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChatByPhone'
     *
     * @param  string $phone (required)
     * @param  int|null $upsert Create a new chat if not found. (optional, default to 0)
     * @param  int|null $reopen Reopen chat if found or do not change status. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChatByPhoneRequest($phone, $upsert = 0, $reopen = 0, string $contentType = self::contentTypes['getChatByPhone'][0])
    {

        // verify the required parameter 'phone' is set
        if ($phone === null || (is_array($phone) && count($phone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone when calling getChatByPhone'
            );
        }




        $resourcePath = '/api/v2/chats/{phone}/by/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $upsert,
            'upsert', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reopen,
            'reopen', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($phone !== null) {
            $resourcePath = str_replace(
                '{' . 'phone' . '}',
                ObjectSerializer::toPathValue($phone),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChatMessages
     *
     * Get chat messages
     *
     * @param  int $id id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $start Return messages since specified timestamp only. Required when &#x60;end&#x60; parameter specified. (optional)
     * @param  string|null $end Return messages up to specified timestamp only. Required when &#x60;start&#x60; parameter specified. (optional)
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $includeNotes Fetch results with messenger notes. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetChatMessagesPaginatedResponse
     */
    public function getChatMessages($id, $page = 1, $limit = 10, $query = null, $start = null, $end = null, $direction = 'desc', $voice = 0, $includeNotes = 0, string $contentType = self::contentTypes['getChatMessages'][0])
    {
        list($response) = $this->getChatMessagesWithHttpInfo($id, $page, $limit, $query, $start, $end, $direction, $voice, $includeNotes, $contentType);
        return $response;
    }

    /**
     * Operation getChatMessagesWithHttpInfo
     *
     * Get chat messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $start Return messages since specified timestamp only. Required when &#x60;end&#x60; parameter specified. (optional)
     * @param  string|null $end Return messages up to specified timestamp only. Required when &#x60;start&#x60; parameter specified. (optional)
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $includeNotes Fetch results with messenger notes. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetChatMessagesPaginatedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChatMessagesWithHttpInfo($id, $page = 1, $limit = 10, $query = null, $start = null, $end = null, $direction = 'desc', $voice = 0, $includeNotes = 0, string $contentType = self::contentTypes['getChatMessages'][0])
    {
        $request = $this->getChatMessagesRequest($id, $page, $limit, $query, $start, $end, $direction, $voice, $includeNotes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetChatMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetChatMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetChatMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getChatMessagesAsync
     *
     * Get chat messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $start Return messages since specified timestamp only. Required when &#x60;end&#x60; parameter specified. (optional)
     * @param  string|null $end Return messages up to specified timestamp only. Required when &#x60;start&#x60; parameter specified. (optional)
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $includeNotes Fetch results with messenger notes. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatMessagesAsync($id, $page = 1, $limit = 10, $query = null, $start = null, $end = null, $direction = 'desc', $voice = 0, $includeNotes = 0, string $contentType = self::contentTypes['getChatMessages'][0])
    {
        return $this->getChatMessagesAsyncWithHttpInfo($id, $page, $limit, $query, $start, $end, $direction, $voice, $includeNotes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChatMessagesAsyncWithHttpInfo
     *
     * Get chat messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $start Return messages since specified timestamp only. Required when &#x60;end&#x60; parameter specified. (optional)
     * @param  string|null $end Return messages up to specified timestamp only. Required when &#x60;start&#x60; parameter specified. (optional)
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $includeNotes Fetch results with messenger notes. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChatMessagesAsyncWithHttpInfo($id, $page = 1, $limit = 10, $query = null, $start = null, $end = null, $direction = 'desc', $voice = 0, $includeNotes = 0, string $contentType = self::contentTypes['getChatMessages'][0])
    {
        $returnType = '\TextMagic\Models\GetChatMessagesPaginatedResponse';
        $request = $this->getChatMessagesRequest($id, $page, $limit, $query, $start, $end, $direction, $voice, $includeNotes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChatMessages'
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $start Return messages since specified timestamp only. Required when &#x60;end&#x60; parameter specified. (optional)
     * @param  string|null $end Return messages up to specified timestamp only. Required when &#x60;start&#x60; parameter specified. (optional)
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $voice Fetch results with voice calls. (optional, default to 0)
     * @param  int|null $includeNotes Fetch results with messenger notes. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChatMessagesRequest($id, $page = 1, $limit = 10, $query = null, $start = null, $end = null, $direction = 'desc', $voice = 0, $includeNotes = 0, string $contentType = self::contentTypes['getChatMessages'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getChatMessages'
            );
        }










        $resourcePath = '/api/v2/chats/{id}/message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voice,
            'voice', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeNotes,
            'includeNotes', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContact
     *
     * Get the details of a specific contact
     *
     * @param  int $id Contact ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\Contact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContact($id, string $contentType = self::contentTypes['getContact'][0])
    {
        list($response) = $this->getContactWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getContactWithHttpInfo
     *
     * Get the details of a specific contact
     *
     * @param  int $id Contact ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\Contact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactWithHttpInfo($id, string $contentType = self::contentTypes['getContact'][0])
    {
        $request = $this->getContactRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\Contact',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\Contact',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactAsync
     *
     * Get the details of a specific contact
     *
     * @param  int $id Contact ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAsync($id, string $contentType = self::contentTypes['getContact'][0])
    {
        return $this->getContactAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAsyncWithHttpInfo
     *
     * Get the details of a specific contact
     *
     * @param  int $id Contact ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getContact'][0])
    {
        $returnType = '\TextMagic\Models\Contact';
        $request = $this->getContactRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContact'
     *
     * @param  int $id Contact ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactRequest($id, string $contentType = self::contentTypes['getContact'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getContact'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactByPhone
     *
     * Get the details of a specific contact by phone number
     *
     * @param  string $phone phone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactByPhone'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\Contact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContactByPhone($phone, string $contentType = self::contentTypes['getContactByPhone'][0])
    {
        list($response) = $this->getContactByPhoneWithHttpInfo($phone, $contentType);
        return $response;
    }

    /**
     * Operation getContactByPhoneWithHttpInfo
     *
     * Get the details of a specific contact by phone number
     *
     * @param  string $phone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactByPhone'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\Contact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactByPhoneWithHttpInfo($phone, string $contentType = self::contentTypes['getContactByPhone'][0])
    {
        $request = $this->getContactByPhoneRequest($phone, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\Contact',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\Contact',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactByPhoneAsync
     *
     * Get the details of a specific contact by phone number
     *
     * @param  string $phone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactByPhoneAsync($phone, string $contentType = self::contentTypes['getContactByPhone'][0])
    {
        return $this->getContactByPhoneAsyncWithHttpInfo($phone, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactByPhoneAsyncWithHttpInfo
     *
     * Get the details of a specific contact by phone number
     *
     * @param  string $phone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactByPhoneAsyncWithHttpInfo($phone, string $contentType = self::contentTypes['getContactByPhone'][0])
    {
        $returnType = '\TextMagic\Models\Contact';
        $request = $this->getContactByPhoneRequest($phone, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactByPhone'
     *
     * @param  string $phone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactByPhoneRequest($phone, string $contentType = self::contentTypes['getContactByPhone'][0])
    {

        // verify the required parameter 'phone' is set
        if ($phone === null || (is_array($phone) && count($phone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone when calling getContactByPhone'
            );
        }


        $resourcePath = '/api/v2/contacts/phone/{phone}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($phone !== null) {
            $resourcePath = str_replace(
                '{' . 'phone' . '}',
                ObjectSerializer::toPathValue($phone),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactIfBlocked
     *
     * Check if a phone number is blocked
     *
     * @param  string $phone Phone number to check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactIfBlocked'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\Contact|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getContactIfBlocked($phone, string $contentType = self::contentTypes['getContactIfBlocked'][0])
    {
        list($response) = $this->getContactIfBlockedWithHttpInfo($phone, $contentType);
        return $response;
    }

    /**
     * Operation getContactIfBlockedWithHttpInfo
     *
     * Check if a phone number is blocked
     *
     * @param  string $phone Phone number to check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactIfBlocked'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\Contact|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactIfBlockedWithHttpInfo($phone, string $contentType = self::contentTypes['getContactIfBlocked'][0])
    {
        $request = $this->getContactIfBlockedRequest($phone, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\Contact',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\Contact',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactIfBlockedAsync
     *
     * Check if a phone number is blocked
     *
     * @param  string $phone Phone number to check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactIfBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactIfBlockedAsync($phone, string $contentType = self::contentTypes['getContactIfBlocked'][0])
    {
        return $this->getContactIfBlockedAsyncWithHttpInfo($phone, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactIfBlockedAsyncWithHttpInfo
     *
     * Check if a phone number is blocked
     *
     * @param  string $phone Phone number to check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactIfBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactIfBlockedAsyncWithHttpInfo($phone, string $contentType = self::contentTypes['getContactIfBlocked'][0])
    {
        $returnType = '\TextMagic\Models\Contact';
        $request = $this->getContactIfBlockedRequest($phone, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactIfBlocked'
     *
     * @param  string $phone Phone number to check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactIfBlocked'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactIfBlockedRequest($phone, string $contentType = self::contentTypes['getContactIfBlocked'][0])
    {

        // verify the required parameter 'phone' is set
        if ($phone === null || (is_array($phone) && count($phone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone when calling getContactIfBlocked'
            );
        }


        $resourcePath = '/api/v2/contacts/block/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone,
            'phone', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactImportSessionProgress
     *
     * Check import progress
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactImportSessionProgress'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetContactImportSessionProgressResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContactImportSessionProgress($id, string $contentType = self::contentTypes['getContactImportSessionProgress'][0])
    {
        list($response) = $this->getContactImportSessionProgressWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getContactImportSessionProgressWithHttpInfo
     *
     * Check import progress
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactImportSessionProgress'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetContactImportSessionProgressResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactImportSessionProgressWithHttpInfo($id, string $contentType = self::contentTypes['getContactImportSessionProgress'][0])
    {
        $request = $this->getContactImportSessionProgressRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetContactImportSessionProgressResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetContactImportSessionProgressResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetContactImportSessionProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactImportSessionProgressAsync
     *
     * Check import progress
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactImportSessionProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactImportSessionProgressAsync($id, string $contentType = self::contentTypes['getContactImportSessionProgress'][0])
    {
        return $this->getContactImportSessionProgressAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactImportSessionProgressAsyncWithHttpInfo
     *
     * Check import progress
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactImportSessionProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactImportSessionProgressAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getContactImportSessionProgress'][0])
    {
        $returnType = '\TextMagic\Models\GetContactImportSessionProgressResponse';
        $request = $this->getContactImportSessionProgressRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactImportSessionProgress'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactImportSessionProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactImportSessionProgressRequest($id, string $contentType = self::contentTypes['getContactImportSessionProgress'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getContactImportSessionProgress'
            );
        }


        $resourcePath = '/api/v2/contacts/import/progress/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactNote
     *
     * Get a contact note
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ContactNote|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContactNote($id, string $contentType = self::contentTypes['getContactNote'][0])
    {
        list($response) = $this->getContactNoteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getContactNoteWithHttpInfo
     *
     * Get a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ContactNote|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactNoteWithHttpInfo($id, string $contentType = self::contentTypes['getContactNote'][0])
    {
        $request = $this->getContactNoteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ContactNote',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ContactNote',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ContactNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactNoteAsync
     *
     * Get a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactNoteAsync($id, string $contentType = self::contentTypes['getContactNote'][0])
    {
        return $this->getContactNoteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactNoteAsyncWithHttpInfo
     *
     * Get a contact note
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactNoteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getContactNote'][0])
    {
        $returnType = '\TextMagic\Models\ContactNote';
        $request = $this->getContactNoteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactNote'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactNoteRequest($id, string $contentType = self::contentTypes['getContactNote'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getContactNote'
            );
        }


        $resourcePath = '/api/v2/notes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactNotes
     *
     * Fetch notes assigned to a given contact
     *
     * @param  int $id id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNotes'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetContactNotesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContactNotes($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getContactNotes'][0])
    {
        list($response) = $this->getContactNotesWithHttpInfo($id, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getContactNotesWithHttpInfo
     *
     * Fetch notes assigned to a given contact
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNotes'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetContactNotesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactNotesWithHttpInfo($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getContactNotes'][0])
    {
        $request = $this->getContactNotesRequest($id, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetContactNotesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetContactNotesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetContactNotesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactNotesAsync
     *
     * Fetch notes assigned to a given contact
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactNotesAsync($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getContactNotes'][0])
    {
        return $this->getContactNotesAsyncWithHttpInfo($id, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactNotesAsyncWithHttpInfo
     *
     * Fetch notes assigned to a given contact
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactNotesAsyncWithHttpInfo($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getContactNotes'][0])
    {
        $returnType = '\TextMagic\Models\GetContactNotesPaginatedResponse';
        $request = $this->getContactNotesRequest($id, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactNotes'
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactNotesRequest($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getContactNotes'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getContactNotes'
            );
        }




        $resourcePath = '/api/v2/contacts/{id}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContacts
     *
     * Get all contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getContacts($page = 1, $limit = 10, $shared = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContacts'][0])
    {
        list($response) = $this->getContactsWithHttpInfo($page, $limit, $shared, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getContactsWithHttpInfo
     *
     * Get all contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsWithHttpInfo($page = 1, $limit = 10, $shared = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContacts'][0])
    {
        $request = $this->getContactsRequest($page, $limit, $shared, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetContactsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetContactsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetContactsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactsAsync
     *
     * Get all contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsAsync($page = 1, $limit = 10, $shared = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContacts'][0])
    {
        return $this->getContactsAsyncWithHttpInfo($page, $limit, $shared, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactsAsyncWithHttpInfo
     *
     * Get all contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsAsyncWithHttpInfo($page = 1, $limit = 10, $shared = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContacts'][0])
    {
        $returnType = '\TextMagic\Models\GetContactsPaginatedResponse';
        $request = $this->getContactsRequest($page, $limit, $shared, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContacts'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactsRequest($page = 1, $limit = 10, $shared = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContacts'][0])
    {







        $resourcePath = '/api/v2/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shared,
            'shared', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactsByListId
     *
     * Get all contacts in a list
     *
     * @param  int $id Given group ID. (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactsByListId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetContactsByListIdPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getContactsByListId($id, $page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContactsByListId'][0])
    {
        list($response) = $this->getContactsByListIdWithHttpInfo($id, $page, $limit, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getContactsByListIdWithHttpInfo
     *
     * Get all contacts in a list
     *
     * @param  int $id Given group ID. (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactsByListId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetContactsByListIdPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsByListIdWithHttpInfo($id, $page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContactsByListId'][0])
    {
        $request = $this->getContactsByListIdRequest($id, $page, $limit, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetContactsByListIdPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetContactsByListIdPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetContactsByListIdPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getContactsByListIdAsync
     *
     * Get all contacts in a list
     *
     * @param  int $id Given group ID. (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactsByListId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsByListIdAsync($id, $page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContactsByListId'][0])
    {
        return $this->getContactsByListIdAsyncWithHttpInfo($id, $page, $limit, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactsByListIdAsyncWithHttpInfo
     *
     * Get all contacts in a list
     *
     * @param  int $id Given group ID. (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactsByListId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsByListIdAsyncWithHttpInfo($id, $page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContactsByListId'][0])
    {
        $returnType = '\TextMagic\Models\GetContactsByListIdPaginatedResponse';
        $request = $this->getContactsByListIdRequest($id, $page, $limit, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactsByListId'
     *
     * @param  int $id Given group ID. (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactsByListId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactsByListIdRequest($id, $page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getContactsByListId'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getContactsByListId'
            );
        }






        $resourcePath = '/api/v2/lists/{id}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentUser
     *
     * Get current account information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentUser'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\User|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getCurrentUser(string $contentType = self::contentTypes['getCurrentUser'][0])
    {
        list($response) = $this->getCurrentUserWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getCurrentUserWithHttpInfo
     *
     * Get current account information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentUser'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\User|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentUserWithHttpInfo(string $contentType = self::contentTypes['getCurrentUser'][0])
    {
        $request = $this->getCurrentUserRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\User',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\User',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrentUserAsync
     *
     * Get current account information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsync(string $contentType = self::contentTypes['getCurrentUser'][0])
    {
        return $this->getCurrentUserAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentUserAsyncWithHttpInfo
     *
     * Get current account information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsyncWithHttpInfo(string $contentType = self::contentTypes['getCurrentUser'][0])
    {
        $returnType = '\TextMagic\Models\User';
        $request = $this->getCurrentUserRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentUser'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrentUserRequest(string $contentType = self::contentTypes['getCurrentUser'][0])
    {


        $resourcePath = '/api/v2/user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomField
     *
     * Get the details of a specific custom field
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UserCustomField|\TextMagic\Models\UnauthorizedResponse
     */
    public function getCustomField($id, string $contentType = self::contentTypes['getCustomField'][0])
    {
        list($response) = $this->getCustomFieldWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getCustomFieldWithHttpInfo
     *
     * Get the details of a specific custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UserCustomField|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomFieldWithHttpInfo($id, string $contentType = self::contentTypes['getCustomField'][0])
    {
        $request = $this->getCustomFieldRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UserCustomField',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UserCustomField',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UserCustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCustomFieldAsync
     *
     * Get the details of a specific custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldAsync($id, string $contentType = self::contentTypes['getCustomField'][0])
    {
        return $this->getCustomFieldAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomFieldAsyncWithHttpInfo
     *
     * Get the details of a specific custom field
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getCustomField'][0])
    {
        $returnType = '\TextMagic\Models\UserCustomField';
        $request = $this->getCustomFieldRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomField'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomFieldRequest($id, string $contentType = self::contentTypes['getCustomField'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCustomField'
            );
        }


        $resourcePath = '/api/v2/customfields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomFields
     *
     * Get all custom fields
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomFields'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetCustomFieldsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getCustomFields($page = 1, $limit = 10, string $contentType = self::contentTypes['getCustomFields'][0])
    {
        list($response) = $this->getCustomFieldsWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getCustomFieldsWithHttpInfo
     *
     * Get all custom fields
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomFields'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetCustomFieldsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomFieldsWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getCustomFields'][0])
    {
        $request = $this->getCustomFieldsRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetCustomFieldsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetCustomFieldsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetCustomFieldsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCustomFieldsAsync
     *
     * Get all custom fields
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldsAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getCustomFields'][0])
    {
        return $this->getCustomFieldsAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomFieldsAsyncWithHttpInfo
     *
     * Get all custom fields
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldsAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getCustomFields'][0])
    {
        $returnType = '\TextMagic\Models\GetCustomFieldsPaginatedResponse';
        $request = $this->getCustomFieldsRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomFields'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomFieldsRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getCustomFields'][0])
    {




        $resourcePath = '/api/v2/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDedicatedNumber
     *
     * Get the details of a specific dedicated number
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UsersInbound|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getDedicatedNumber($id, string $contentType = self::contentTypes['getDedicatedNumber'][0])
    {
        list($response) = $this->getDedicatedNumberWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getDedicatedNumberWithHttpInfo
     *
     * Get the details of a specific dedicated number
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UsersInbound|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDedicatedNumberWithHttpInfo($id, string $contentType = self::contentTypes['getDedicatedNumber'][0])
    {
        $request = $this->getDedicatedNumberRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UsersInbound',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UsersInbound',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UsersInbound',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDedicatedNumberAsync
     *
     * Get the details of a specific dedicated number
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDedicatedNumberAsync($id, string $contentType = self::contentTypes['getDedicatedNumber'][0])
    {
        return $this->getDedicatedNumberAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDedicatedNumberAsyncWithHttpInfo
     *
     * Get the details of a specific dedicated number
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDedicatedNumberAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getDedicatedNumber'][0])
    {
        $returnType = '\TextMagic\Models\UsersInbound';
        $request = $this->getDedicatedNumberRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDedicatedNumber'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDedicatedNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDedicatedNumberRequest($id, string $contentType = self::contentTypes['getDedicatedNumber'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDedicatedNumber'
            );
        }


        $resourcePath = '/api/v2/numbers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailSenders
     *
     * Get list of email senders
     *
     * @param  int|null $domainId Filter email senders by specific domain ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmailSenders'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetEmailSendersResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getEmailSenders($domainId = null, string $contentType = self::contentTypes['getEmailSenders'][0])
    {
        list($response) = $this->getEmailSendersWithHttpInfo($domainId, $contentType);
        return $response;
    }

    /**
     * Operation getEmailSendersWithHttpInfo
     *
     * Get list of email senders
     *
     * @param  int|null $domainId Filter email senders by specific domain ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmailSenders'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetEmailSendersResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailSendersWithHttpInfo($domainId = null, string $contentType = self::contentTypes['getEmailSenders'][0])
    {
        $request = $this->getEmailSendersRequest($domainId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetEmailSendersResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetEmailSendersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetEmailSendersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEmailSendersAsync
     *
     * Get list of email senders
     *
     * @param  int|null $domainId Filter email senders by specific domain ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmailSenders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailSendersAsync($domainId = null, string $contentType = self::contentTypes['getEmailSenders'][0])
    {
        return $this->getEmailSendersAsyncWithHttpInfo($domainId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailSendersAsyncWithHttpInfo
     *
     * Get list of email senders
     *
     * @param  int|null $domainId Filter email senders by specific domain ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmailSenders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailSendersAsyncWithHttpInfo($domainId = null, string $contentType = self::contentTypes['getEmailSenders'][0])
    {
        $returnType = '\TextMagic\Models\GetEmailSendersResponse';
        $request = $this->getEmailSendersRequest($domainId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailSenders'
     *
     * @param  int|null $domainId Filter email senders by specific domain ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmailSenders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEmailSendersRequest($domainId = null, string $contentType = self::contentTypes['getEmailSenders'][0])
    {



        $resourcePath = '/api/v2/email-campaigns/email-senders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domainId,
            'domainId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFavorites
     *
     * Get favorite contacts and lists
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find contacts or lists by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavorites'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetFavoritesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getFavorites($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['getFavorites'][0])
    {
        list($response) = $this->getFavoritesWithHttpInfo($page, $limit, $query, $contentType);
        return $response;
    }

    /**
     * Operation getFavoritesWithHttpInfo
     *
     * Get favorite contacts and lists
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find contacts or lists by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavorites'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetFavoritesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFavoritesWithHttpInfo($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['getFavorites'][0])
    {
        $request = $this->getFavoritesRequest($page, $limit, $query, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetFavoritesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetFavoritesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetFavoritesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFavoritesAsync
     *
     * Get favorite contacts and lists
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find contacts or lists by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFavoritesAsync($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['getFavorites'][0])
    {
        return $this->getFavoritesAsyncWithHttpInfo($page, $limit, $query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFavoritesAsyncWithHttpInfo
     *
     * Get favorite contacts and lists
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find contacts or lists by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFavoritesAsyncWithHttpInfo($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['getFavorites'][0])
    {
        $returnType = '\TextMagic\Models\GetFavoritesPaginatedResponse';
        $request = $this->getFavoritesRequest($page, $limit, $query, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFavorites'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find contacts or lists by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFavoritesRequest($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['getFavorites'][0])
    {





        $resourcePath = '/api/v2/contacts/favorite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundMessage
     *
     * Get a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\MessageIn|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getInboundMessage($id, string $contentType = self::contentTypes['getInboundMessage'][0])
    {
        list($response) = $this->getInboundMessageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getInboundMessageWithHttpInfo
     *
     * Get a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\MessageIn|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboundMessageWithHttpInfo($id, string $contentType = self::contentTypes['getInboundMessage'][0])
    {
        $request = $this->getInboundMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\MessageIn',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\MessageIn',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\MessageIn',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInboundMessageAsync
     *
     * Get a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundMessageAsync($id, string $contentType = self::contentTypes['getInboundMessage'][0])
    {
        return $this->getInboundMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundMessageAsyncWithHttpInfo
     *
     * Get a single inbound message
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getInboundMessage'][0])
    {
        $returnType = '\TextMagic\Models\MessageIn';
        $request = $this->getInboundMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundMessage'
     *
     * @param  int $id The unique numeric ID for the inbound message. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInboundMessageRequest($id, string $contentType = self::contentTypes['getInboundMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInboundMessage'
            );
        }


        $resourcePath = '/api/v2/replies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundMessagesNotificationSettings
     *
     * Get inbound messages notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetInboundMessagesNotificationSettingsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getInboundMessagesNotificationSettings(string $contentType = self::contentTypes['getInboundMessagesNotificationSettings'][0])
    {
        list($response) = $this->getInboundMessagesNotificationSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getInboundMessagesNotificationSettingsWithHttpInfo
     *
     * Get inbound messages notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetInboundMessagesNotificationSettingsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboundMessagesNotificationSettingsWithHttpInfo(string $contentType = self::contentTypes['getInboundMessagesNotificationSettings'][0])
    {
        $request = $this->getInboundMessagesNotificationSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetInboundMessagesNotificationSettingsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetInboundMessagesNotificationSettingsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetInboundMessagesNotificationSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInboundMessagesNotificationSettingsAsync
     *
     * Get inbound messages notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundMessagesNotificationSettingsAsync(string $contentType = self::contentTypes['getInboundMessagesNotificationSettings'][0])
    {
        return $this->getInboundMessagesNotificationSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundMessagesNotificationSettingsAsyncWithHttpInfo
     *
     * Get inbound messages notification settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundMessagesNotificationSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getInboundMessagesNotificationSettings'][0])
    {
        $returnType = '\TextMagic\Models\GetInboundMessagesNotificationSettingsResponse';
        $request = $this->getInboundMessagesNotificationSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundMessagesNotificationSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInboundMessagesNotificationSettingsRequest(string $contentType = self::contentTypes['getInboundMessagesNotificationSettings'][0])
    {


        $resourcePath = '/api/v2/user/notification/inbound';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoices
     *
     * Get all invoices
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoices'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetInvoicesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getInvoices($page = 1, $limit = 10, string $contentType = self::contentTypes['getInvoices'][0])
    {
        list($response) = $this->getInvoicesWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getInvoicesWithHttpInfo
     *
     * Get all invoices
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoices'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetInvoicesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoicesWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getInvoices'][0])
    {
        $request = $this->getInvoicesRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetInvoicesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetInvoicesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetInvoicesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInvoicesAsync
     *
     * Get all invoices
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getInvoices'][0])
    {
        return $this->getInvoicesAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoicesAsyncWithHttpInfo
     *
     * Get all invoices
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getInvoices'][0])
    {
        $returnType = '\TextMagic\Models\GetInvoicesPaginatedResponse';
        $request = $this->getInvoicesRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoices'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvoicesRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getInvoices'][0])
    {




        $resourcePath = '/api/v2/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getList
     *
     * Get the details of a specific list
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ModelList|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getList($id, string $contentType = self::contentTypes['getList'][0])
    {
        list($response) = $this->getListWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getListWithHttpInfo
     *
     * Get the details of a specific list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ModelList|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListWithHttpInfo($id, string $contentType = self::contentTypes['getList'][0])
    {
        $request = $this->getListRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ModelList',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ModelList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ModelList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getListAsync
     *
     * Get the details of a specific list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListAsync($id, string $contentType = self::contentTypes['getList'][0])
    {
        return $this->getListAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListAsyncWithHttpInfo
     *
     * Get the details of a specific list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getList'][0])
    {
        $returnType = '\TextMagic\Models\ModelList';
        $request = $this->getListRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getList'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getListRequest($id, string $contentType = self::contentTypes['getList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getList'
            );
        }


        $resourcePath = '/api/v2/lists/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListContactsIds
     *
     * Get all contact IDs in a list
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListContactsIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int[]|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getListContactsIds($id, string $contentType = self::contentTypes['getListContactsIds'][0])
    {
        list($response) = $this->getListContactsIdsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getListContactsIdsWithHttpInfo
     *
     * Get all contact IDs in a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListContactsIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int[]|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListContactsIdsWithHttpInfo($id, string $contentType = self::contentTypes['getListContactsIds'][0])
    {
        $request = $this->getListContactsIdsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'int[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'int[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getListContactsIdsAsync
     *
     * Get all contact IDs in a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListContactsIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListContactsIdsAsync($id, string $contentType = self::contentTypes['getListContactsIds'][0])
    {
        return $this->getListContactsIdsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListContactsIdsAsyncWithHttpInfo
     *
     * Get all contact IDs in a list
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListContactsIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListContactsIdsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getListContactsIds'][0])
    {
        $returnType = 'int[]';
        $request = $this->getListContactsIdsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListContactsIds'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListContactsIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getListContactsIdsRequest($id, string $contentType = self::contentTypes['getListContactsIds'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getListContactsIds'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/contacts/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLists
     *
     * Get all lists
     *
     * @param  int|null $page The current fetched page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $favoriteOnly Return only favorited lists. (optional, default to 0)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLists'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetListsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getLists($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', $favoriteOnly = 0, $onlyMine = 0, string $contentType = self::contentTypes['getLists'][0])
    {
        list($response) = $this->getListsWithHttpInfo($page, $limit, $orderBy, $direction, $favoriteOnly, $onlyMine, $contentType);
        return $response;
    }

    /**
     * Operation getListsWithHttpInfo
     *
     * Get all lists
     *
     * @param  int|null $page The current fetched page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $favoriteOnly Return only favorited lists. (optional, default to 0)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLists'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetListsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListsWithHttpInfo($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', $favoriteOnly = 0, $onlyMine = 0, string $contentType = self::contentTypes['getLists'][0])
    {
        $request = $this->getListsRequest($page, $limit, $orderBy, $direction, $favoriteOnly, $onlyMine, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetListsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetListsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetListsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getListsAsync
     *
     * Get all lists
     *
     * @param  int|null $page The current fetched page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $favoriteOnly Return only favorited lists. (optional, default to 0)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsAsync($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', $favoriteOnly = 0, $onlyMine = 0, string $contentType = self::contentTypes['getLists'][0])
    {
        return $this->getListsAsyncWithHttpInfo($page, $limit, $orderBy, $direction, $favoriteOnly, $onlyMine, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListsAsyncWithHttpInfo
     *
     * Get all lists
     *
     * @param  int|null $page The current fetched page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $favoriteOnly Return only favorited lists. (optional, default to 0)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsAsyncWithHttpInfo($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', $favoriteOnly = 0, $onlyMine = 0, string $contentType = self::contentTypes['getLists'][0])
    {
        $returnType = '\TextMagic\Models\GetListsPaginatedResponse';
        $request = $this->getListsRequest($page, $limit, $orderBy, $direction, $favoriteOnly, $onlyMine, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLists'
     *
     * @param  int|null $page The current fetched page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $favoriteOnly Return only favorited lists. (optional, default to 0)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getListsRequest($page = 1, $limit = 10, $orderBy = 'id', $direction = 'desc', $favoriteOnly = 0, $onlyMine = 0, string $contentType = self::contentTypes['getLists'][0])
    {








        $resourcePath = '/api/v2/lists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $favoriteOnly,
            'favoriteOnly', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyMine,
            'onlyMine', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListsOfContact
     *
     * Get a contact&#39;s lists
     *
     * @param  int $id id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListsOfContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetListsOfContactPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getListsOfContact($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getListsOfContact'][0])
    {
        list($response) = $this->getListsOfContactWithHttpInfo($id, $page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getListsOfContactWithHttpInfo
     *
     * Get a contact&#39;s lists
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListsOfContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetListsOfContactPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListsOfContactWithHttpInfo($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getListsOfContact'][0])
    {
        $request = $this->getListsOfContactRequest($id, $page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetListsOfContactPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetListsOfContactPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetListsOfContactPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getListsOfContactAsync
     *
     * Get a contact&#39;s lists
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListsOfContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsOfContactAsync($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getListsOfContact'][0])
    {
        return $this->getListsOfContactAsyncWithHttpInfo($id, $page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListsOfContactAsyncWithHttpInfo
     *
     * Get a contact&#39;s lists
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListsOfContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsOfContactAsyncWithHttpInfo($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getListsOfContact'][0])
    {
        $returnType = '\TextMagic\Models\GetListsOfContactPaginatedResponse';
        $request = $this->getListsOfContactRequest($id, $page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListsOfContact'
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getListsOfContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getListsOfContactRequest($id, $page = 1, $limit = 10, string $contentType = self::contentTypes['getListsOfContact'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getListsOfContact'
            );
        }




        $resourcePath = '/api/v2/contacts/{id}/lists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessagePreview
     *
     * Preview message
     *
     * @param  string|null $text Message text. Required if **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending of 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat(if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePreview'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetMessagePreviewResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getMessagePreview($text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePreview'][0])
    {
        list($response) = $this->getMessagePreviewWithHttpInfo($text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);
        return $response;
    }

    /**
     * Operation getMessagePreviewWithHttpInfo
     *
     * Preview message
     *
     * @param  string|null $text Message text. Required if **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending of 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat(if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePreview'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetMessagePreviewResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessagePreviewWithHttpInfo($text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePreview'][0])
    {
        $request = $this->getMessagePreviewRequest($text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetMessagePreviewResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetMessagePreviewResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetMessagePreviewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessagePreviewAsync
     *
     * Preview message
     *
     * @param  string|null $text Message text. Required if **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending of 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat(if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagePreviewAsync($text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePreview'][0])
    {
        return $this->getMessagePreviewAsyncWithHttpInfo($text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessagePreviewAsyncWithHttpInfo
     *
     * Preview message
     *
     * @param  string|null $text Message text. Required if **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending of 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat(if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagePreviewAsyncWithHttpInfo($text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePreview'][0])
    {
        $returnType = '\TextMagic\Models\GetMessagePreviewResponse';
        $request = $this->getMessagePreviewRequest($text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessagePreview'
     *
     * @param  string|null $text Message text. Required if **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending of 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat(if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessagePreviewRequest($text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePreview'][0])
    {



















        $resourcePath = '/api/v2/messages/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $templateId,
            'templateId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingTime,
            'sendingTime', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingDateTime,
            'sendingDateTime', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingTimezone,
            'sendingTimezone', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contacts,
            'contacts', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lists,
            'lists', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phones,
            'phones', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cutExtra,
            'cutExtra', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partsCount,
            'partsCount', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referenceId,
            'referenceId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rule,
            'rule', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $createChat,
            'createChat', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tts,
            'tts', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $local,
            'local', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $localCountry,
            'localCountry', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessagePrice
     *
     * Check message price
     *
     * @param  int|null $includeBlocked Should we show the pricing for blocked contacts? (optional, default to 0)
     * @param  string|null $text Message text. Required if the **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if the **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat (if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send a Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePrice'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetMessagePriceResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getMessagePrice($includeBlocked = 0, $text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePrice'][0])
    {
        list($response) = $this->getMessagePriceWithHttpInfo($includeBlocked, $text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);
        return $response;
    }

    /**
     * Operation getMessagePriceWithHttpInfo
     *
     * Check message price
     *
     * @param  int|null $includeBlocked Should we show the pricing for blocked contacts? (optional, default to 0)
     * @param  string|null $text Message text. Required if the **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if the **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat (if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send a Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePrice'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetMessagePriceResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessagePriceWithHttpInfo($includeBlocked = 0, $text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePrice'][0])
    {
        $request = $this->getMessagePriceRequest($includeBlocked, $text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetMessagePriceResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetMessagePriceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetMessagePriceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessagePriceAsync
     *
     * Check message price
     *
     * @param  int|null $includeBlocked Should we show the pricing for blocked contacts? (optional, default to 0)
     * @param  string|null $text Message text. Required if the **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if the **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat (if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send a Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagePriceAsync($includeBlocked = 0, $text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePrice'][0])
    {
        return $this->getMessagePriceAsyncWithHttpInfo($includeBlocked, $text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessagePriceAsyncWithHttpInfo
     *
     * Check message price
     *
     * @param  int|null $includeBlocked Should we show the pricing for blocked contacts? (optional, default to 0)
     * @param  string|null $text Message text. Required if the **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if the **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat (if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send a Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagePriceAsyncWithHttpInfo($includeBlocked = 0, $text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePrice'][0])
    {
        $returnType = '\TextMagic\Models\GetMessagePriceResponse';
        $request = $this->getMessagePriceRequest($includeBlocked, $text, $templateId, $sendingTime, $sendingDateTime, $sendingTimezone, $contacts, $lists, $phones, $cutExtra, $partsCount, $referenceId, $from, $rule, $createChat, $tts, $local, $localCountry, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessagePrice'
     *
     * @param  int|null $includeBlocked Should we show the pricing for blocked contacts? (optional, default to 0)
     * @param  string|null $text Message text. Required if the **template_id** is not set. (optional)
     * @param  int|null $templateId Template used instead of message text. Required if the **text** is not set. (optional)
     * @param  int|null $sendingTime DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now. (optional)
     * @param  string|null $sendingDateTime Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone. (optional)
     * @param  string|null $sendingTimezone The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone. (optional)
     * @param  string|null $contacts Comma-separated array of contact resources id message will be sent to. (optional)
     * @param  string|null $lists Comma-separated array of list resources id message will be sent to. (optional)
     * @param  string|null $phones Comma-separated array of E.164 phone numbers message will be sent to. (optional)
     * @param  int|null $cutExtra Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. (optional, default to 0)
     * @param  int|null $partsCount Maximum message parts count (Textmagic allows sending 1 to 6 message parts). (optional, default to 6)
     * @param  int|null $referenceId Custom message reference id which can be used in your application infrastructure. (optional)
     * @param  string|null $from One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs). (optional)
     * @param  string|null $rule An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details. (optional)
     * @param  int|null $createChat Should the sending method try to create new Chat (if not exist) with specified recipients? (optional, default to 0)
     * @param  int|null $tts Send a Text-to-Speech message. (optional, default to 0)
     * @param  int|null $local Treat phone numbers passed in the \\&#39;phones\\&#39; field as local. (optional, default to 0)
     * @param  string|null $localCountry The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagePrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessagePriceRequest($includeBlocked = 0, $text = null, $templateId = null, $sendingTime = null, $sendingDateTime = null, $sendingTimezone = null, $contacts = null, $lists = null, $phones = null, $cutExtra = 0, $partsCount = 6, $referenceId = null, $from = null, $rule = null, $createChat = 0, $tts = 0, $local = 0, $localCountry = null, string $contentType = self::contentTypes['getMessagePrice'][0])
    {




















        $resourcePath = '/api/v2/messages/price/normalized';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeBlocked,
            'includeBlocked', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $templateId,
            'templateId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingTime,
            'sendingTime', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingDateTime,
            'sendingDateTime', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendingTimezone,
            'sendingTimezone', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contacts,
            'contacts', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lists,
            'lists', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phones,
            'phones', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cutExtra,
            'cutExtra', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partsCount,
            'partsCount', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referenceId,
            'referenceId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rule,
            'rule', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $createChat,
            'createChat', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tts,
            'tts', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $local,
            'local', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $localCountry,
            'localCountry', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageSession
     *
     * Get a session&#x60;s details
     *
     * @param  int $id Session ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\MessageSession|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getMessageSession($id, string $contentType = self::contentTypes['getMessageSession'][0])
    {
        list($response) = $this->getMessageSessionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getMessageSessionWithHttpInfo
     *
     * Get a session&#x60;s details
     *
     * @param  int $id Session ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSession'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\MessageSession|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageSessionWithHttpInfo($id, string $contentType = self::contentTypes['getMessageSession'][0])
    {
        $request = $this->getMessageSessionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\MessageSession',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\MessageSession',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\MessageSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessageSessionAsync
     *
     * Get a session&#x60;s details
     *
     * @param  int $id Session ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageSessionAsync($id, string $contentType = self::contentTypes['getMessageSession'][0])
    {
        return $this->getMessageSessionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageSessionAsyncWithHttpInfo
     *
     * Get a session&#x60;s details
     *
     * @param  int $id Session ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageSessionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getMessageSession'][0])
    {
        $returnType = '\TextMagic\Models\MessageSession';
        $request = $this->getMessageSessionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageSession'
     *
     * @param  int $id Session ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageSessionRequest($id, string $contentType = self::contentTypes['getMessageSession'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMessageSession'
            );
        }


        $resourcePath = '/api/v2/sessions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageSessionStat
     *
     * Get a session&#x60;s statistics
     *
     * @param  int $id id (required)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSessionStat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetMessageSessionStatResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getMessageSessionStat($id, $includeDeleted = 0, string $contentType = self::contentTypes['getMessageSessionStat'][0])
    {
        list($response) = $this->getMessageSessionStatWithHttpInfo($id, $includeDeleted, $contentType);
        return $response;
    }

    /**
     * Operation getMessageSessionStatWithHttpInfo
     *
     * Get a session&#x60;s statistics
     *
     * @param  int $id (required)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSessionStat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetMessageSessionStatResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageSessionStatWithHttpInfo($id, $includeDeleted = 0, string $contentType = self::contentTypes['getMessageSessionStat'][0])
    {
        $request = $this->getMessageSessionStatRequest($id, $includeDeleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetMessageSessionStatResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetMessageSessionStatResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetMessageSessionStatResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessageSessionStatAsync
     *
     * Get a session&#x60;s statistics
     *
     * @param  int $id (required)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSessionStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageSessionStatAsync($id, $includeDeleted = 0, string $contentType = self::contentTypes['getMessageSessionStat'][0])
    {
        return $this->getMessageSessionStatAsyncWithHttpInfo($id, $includeDeleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageSessionStatAsyncWithHttpInfo
     *
     * Get a session&#x60;s statistics
     *
     * @param  int $id (required)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSessionStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageSessionStatAsyncWithHttpInfo($id, $includeDeleted = 0, string $contentType = self::contentTypes['getMessageSessionStat'][0])
    {
        $returnType = '\TextMagic\Models\GetMessageSessionStatResponse';
        $request = $this->getMessageSessionStatRequest($id, $includeDeleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageSessionStat'
     *
     * @param  int $id (required)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageSessionStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageSessionStatRequest($id, $includeDeleted = 0, string $contentType = self::contentTypes['getMessageSessionStat'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMessageSessionStat'
            );
        }



        $resourcePath = '/api/v2/sessions/{id}/stat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeDeleted,
            'includeDeleted', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessagesBySessionId
     *
     * Get a session&#x60;s messages
     *
     * @param  int $id id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagesBySessionId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetMessagesBySessionIdPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getMessagesBySessionId($id, $page = 1, $limit = 10, $statuses = null, $includeDeleted = 0, string $contentType = self::contentTypes['getMessagesBySessionId'][0])
    {
        list($response) = $this->getMessagesBySessionIdWithHttpInfo($id, $page, $limit, $statuses, $includeDeleted, $contentType);
        return $response;
    }

    /**
     * Operation getMessagesBySessionIdWithHttpInfo
     *
     * Get a session&#x60;s messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagesBySessionId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetMessagesBySessionIdPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessagesBySessionIdWithHttpInfo($id, $page = 1, $limit = 10, $statuses = null, $includeDeleted = 0, string $contentType = self::contentTypes['getMessagesBySessionId'][0])
    {
        $request = $this->getMessagesBySessionIdRequest($id, $page, $limit, $statuses, $includeDeleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetMessagesBySessionIdPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetMessagesBySessionIdPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetMessagesBySessionIdPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessagesBySessionIdAsync
     *
     * Get a session&#x60;s messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagesBySessionId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagesBySessionIdAsync($id, $page = 1, $limit = 10, $statuses = null, $includeDeleted = 0, string $contentType = self::contentTypes['getMessagesBySessionId'][0])
    {
        return $this->getMessagesBySessionIdAsyncWithHttpInfo($id, $page, $limit, $statuses, $includeDeleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessagesBySessionIdAsyncWithHttpInfo
     *
     * Get a session&#x60;s messages
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagesBySessionId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagesBySessionIdAsyncWithHttpInfo($id, $page = 1, $limit = 10, $statuses = null, $includeDeleted = 0, string $contentType = self::contentTypes['getMessagesBySessionId'][0])
    {
        $returnType = '\TextMagic\Models\GetMessagesBySessionIdPaginatedResponse';
        $request = $this->getMessagesBySessionIdRequest($id, $page, $limit, $statuses, $includeDeleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessagesBySessionId'
     *
     * @param  int $id (required)
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagesBySessionId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessagesBySessionIdRequest($id, $page = 1, $limit = 10, $statuses = null, $includeDeleted = 0, string $contentType = self::contentTypes['getMessagesBySessionId'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMessagesBySessionId'
            );
        }






        $resourcePath = '/api/v2/sessions/{id}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeDeleted,
            'includeDeleted', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessagingCounters
     *
     * Get sent/received messages counters values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagingCounters'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetMessagingCountersResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getMessagingCounters(string $contentType = self::contentTypes['getMessagingCounters'][0])
    {
        list($response) = $this->getMessagingCountersWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMessagingCountersWithHttpInfo
     *
     * Get sent/received messages counters values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagingCounters'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetMessagingCountersResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessagingCountersWithHttpInfo(string $contentType = self::contentTypes['getMessagingCounters'][0])
    {
        $request = $this->getMessagingCountersRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetMessagingCountersResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetMessagingCountersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetMessagingCountersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMessagingCountersAsync
     *
     * Get sent/received messages counters values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagingCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagingCountersAsync(string $contentType = self::contentTypes['getMessagingCounters'][0])
    {
        return $this->getMessagingCountersAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessagingCountersAsyncWithHttpInfo
     *
     * Get sent/received messages counters values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagingCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessagingCountersAsyncWithHttpInfo(string $contentType = self::contentTypes['getMessagingCounters'][0])
    {
        $returnType = '\TextMagic\Models\GetMessagingCountersResponse';
        $request = $this->getMessagingCountersRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessagingCounters'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessagingCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessagingCountersRequest(string $contentType = self::contentTypes['getMessagingCounters'][0])
    {


        $resourcePath = '/api/v2/stats/messaging/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOutboundMessage
     *
     * Get a single message
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\MessageOut|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getOutboundMessage($id, string $contentType = self::contentTypes['getOutboundMessage'][0])
    {
        list($response) = $this->getOutboundMessageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getOutboundMessageWithHttpInfo
     *
     * Get a single message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\MessageOut|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOutboundMessageWithHttpInfo($id, string $contentType = self::contentTypes['getOutboundMessage'][0])
    {
        $request = $this->getOutboundMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\MessageOut',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\MessageOut',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\MessageOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOutboundMessageAsync
     *
     * Get a single message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutboundMessageAsync($id, string $contentType = self::contentTypes['getOutboundMessage'][0])
    {
        return $this->getOutboundMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOutboundMessageAsyncWithHttpInfo
     *
     * Get a single message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutboundMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getOutboundMessage'][0])
    {
        $returnType = '\TextMagic\Models\MessageOut';
        $request = $this->getOutboundMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOutboundMessage'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOutboundMessageRequest($id, string $contentType = self::contentTypes['getOutboundMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOutboundMessage'
            );
        }


        $resourcePath = '/api/v2/messages/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOutboundMessagesHistory
     *
     * Get history
     *
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. (optional)
     * @param  string|null $query Find message by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessagesHistory'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getOutboundMessagesHistory($limit = 10, $lastId = null, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getOutboundMessagesHistory'][0])
    {
        list($response) = $this->getOutboundMessagesHistoryWithHttpInfo($limit, $lastId, $query, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation getOutboundMessagesHistoryWithHttpInfo
     *
     * Get history
     *
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. (optional)
     * @param  string|null $query Find message by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessagesHistory'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOutboundMessagesHistoryWithHttpInfo($limit = 10, $lastId = null, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getOutboundMessagesHistory'][0])
    {
        $request = $this->getOutboundMessagesHistoryRequest($limit, $lastId, $query, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOutboundMessagesHistoryAsync
     *
     * Get history
     *
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. (optional)
     * @param  string|null $query Find message by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessagesHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutboundMessagesHistoryAsync($limit = 10, $lastId = null, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getOutboundMessagesHistory'][0])
    {
        return $this->getOutboundMessagesHistoryAsyncWithHttpInfo($limit, $lastId, $query, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOutboundMessagesHistoryAsyncWithHttpInfo
     *
     * Get history
     *
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. (optional)
     * @param  string|null $query Find message by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessagesHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOutboundMessagesHistoryAsyncWithHttpInfo($limit = 10, $lastId = null, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getOutboundMessagesHistory'][0])
    {
        $returnType = '\TextMagic\Models\GetOutboundMessagesHistoryPaginatedResponse';
        $request = $this->getOutboundMessagesHistoryRequest($limit, $lastId, $query, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOutboundMessagesHistory'
     *
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. (optional)
     * @param  string|null $query Find message by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOutboundMessagesHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOutboundMessagesHistoryRequest($limit = 10, $lastId = null, $query = null, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['getOutboundMessagesHistory'][0])
    {







        $resourcePath = '/api/v2/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastId,
            'lastId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getScheduledMessage
     *
     * Get a single scheduled message
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\MessagesIcs|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getScheduledMessage($id, string $contentType = self::contentTypes['getScheduledMessage'][0])
    {
        list($response) = $this->getScheduledMessageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getScheduledMessageWithHttpInfo
     *
     * Get a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\MessagesIcs|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getScheduledMessageWithHttpInfo($id, string $contentType = self::contentTypes['getScheduledMessage'][0])
    {
        $request = $this->getScheduledMessageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\MessagesIcs',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\MessagesIcs',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\MessagesIcs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getScheduledMessageAsync
     *
     * Get a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScheduledMessageAsync($id, string $contentType = self::contentTypes['getScheduledMessage'][0])
    {
        return $this->getScheduledMessageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getScheduledMessageAsyncWithHttpInfo
     *
     * Get a single scheduled message
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScheduledMessageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getScheduledMessage'][0])
    {
        $returnType = '\TextMagic\Models\MessagesIcs';
        $request = $this->getScheduledMessageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getScheduledMessage'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getScheduledMessageRequest($id, string $contentType = self::contentTypes['getScheduledMessage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getScheduledMessage'
            );
        }


        $resourcePath = '/api/v2/schedules/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSenderId
     *
     * Get the details of a specific Sender ID
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SenderId|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getSenderId($id, string $contentType = self::contentTypes['getSenderId'][0])
    {
        list($response) = $this->getSenderIdWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getSenderIdWithHttpInfo
     *
     * Get the details of a specific Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SenderId|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSenderIdWithHttpInfo($id, string $contentType = self::contentTypes['getSenderId'][0])
    {
        $request = $this->getSenderIdRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SenderId',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SenderId',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SenderId',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSenderIdAsync
     *
     * Get the details of a specific Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderIdAsync($id, string $contentType = self::contentTypes['getSenderId'][0])
    {
        return $this->getSenderIdAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSenderIdAsyncWithHttpInfo
     *
     * Get the details of a specific Sender ID
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderIdAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getSenderId'][0])
    {
        $returnType = '\TextMagic\Models\SenderId';
        $request = $this->getSenderIdRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSenderId'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSenderIdRequest($id, string $contentType = self::contentTypes['getSenderId'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSenderId'
            );
        }


        $resourcePath = '/api/v2/senderids/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSenderIds
     *
     * Get all your approved Sender IDs
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetSenderIdsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getSenderIds($page = 1, $limit = 10, string $contentType = self::contentTypes['getSenderIds'][0])
    {
        list($response) = $this->getSenderIdsWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getSenderIdsWithHttpInfo
     *
     * Get all your approved Sender IDs
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetSenderIdsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSenderIdsWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getSenderIds'][0])
    {
        $request = $this->getSenderIdsRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetSenderIdsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetSenderIdsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetSenderIdsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSenderIdsAsync
     *
     * Get all your approved Sender IDs
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderIdsAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getSenderIds'][0])
    {
        return $this->getSenderIdsAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSenderIdsAsyncWithHttpInfo
     *
     * Get all your approved Sender IDs
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderIdsAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getSenderIds'][0])
    {
        $returnType = '\TextMagic\Models\GetSenderIdsPaginatedResponse';
        $request = $this->getSenderIdsRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSenderIds'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSenderIdsRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getSenderIds'][0])
    {




        $resourcePath = '/api/v2/senderids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSenderSettings
     *
     * Get current sender settings
     *
     * @param  string|null $country Return sender settings enabled for sending to a specified country. Should be 2 upper-case characters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetSenderSettingsResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getSenderSettings($country = null, string $contentType = self::contentTypes['getSenderSettings'][0])
    {
        list($response) = $this->getSenderSettingsWithHttpInfo($country, $contentType);
        return $response;
    }

    /**
     * Operation getSenderSettingsWithHttpInfo
     *
     * Get current sender settings
     *
     * @param  string|null $country Return sender settings enabled for sending to a specified country. Should be 2 upper-case characters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetSenderSettingsResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSenderSettingsWithHttpInfo($country = null, string $contentType = self::contentTypes['getSenderSettings'][0])
    {
        $request = $this->getSenderSettingsRequest($country, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetSenderSettingsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetSenderSettingsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetSenderSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSenderSettingsAsync
     *
     * Get current sender settings
     *
     * @param  string|null $country Return sender settings enabled for sending to a specified country. Should be 2 upper-case characters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderSettingsAsync($country = null, string $contentType = self::contentTypes['getSenderSettings'][0])
    {
        return $this->getSenderSettingsAsyncWithHttpInfo($country, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSenderSettingsAsyncWithHttpInfo
     *
     * Get current sender settings
     *
     * @param  string|null $country Return sender settings enabled for sending to a specified country. Should be 2 upper-case characters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderSettingsAsyncWithHttpInfo($country = null, string $contentType = self::contentTypes['getSenderSettings'][0])
    {
        $returnType = '\TextMagic\Models\GetSenderSettingsResponse';
        $request = $this->getSenderSettingsRequest($country, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSenderSettings'
     *
     * @param  string|null $country Return sender settings enabled for sending to a specified country. Should be 2 upper-case characters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSenderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSenderSettingsRequest($country = null, string $contentType = self::contentTypes['getSenderSettings'][0])
    {



        $resourcePath = '/api/v2/sender/settings/normalized';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpendingStat
     *
     * Get spending statistics
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $start Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. (optional)
     * @param  string|null $end Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpendingStat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetSpendingStatPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getSpendingStat($page = 1, $limit = 10, $start = null, $end = null, string $contentType = self::contentTypes['getSpendingStat'][0])
    {
        list($response) = $this->getSpendingStatWithHttpInfo($page, $limit, $start, $end, $contentType);
        return $response;
    }

    /**
     * Operation getSpendingStatWithHttpInfo
     *
     * Get spending statistics
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $start Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. (optional)
     * @param  string|null $end Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpendingStat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetSpendingStatPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpendingStatWithHttpInfo($page = 1, $limit = 10, $start = null, $end = null, string $contentType = self::contentTypes['getSpendingStat'][0])
    {
        $request = $this->getSpendingStatRequest($page, $limit, $start, $end, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetSpendingStatPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetSpendingStatPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetSpendingStatPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpendingStatAsync
     *
     * Get spending statistics
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $start Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. (optional)
     * @param  string|null $end Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpendingStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpendingStatAsync($page = 1, $limit = 10, $start = null, $end = null, string $contentType = self::contentTypes['getSpendingStat'][0])
    {
        return $this->getSpendingStatAsyncWithHttpInfo($page, $limit, $start, $end, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpendingStatAsyncWithHttpInfo
     *
     * Get spending statistics
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $start Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. (optional)
     * @param  string|null $end Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpendingStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpendingStatAsyncWithHttpInfo($page = 1, $limit = 10, $start = null, $end = null, string $contentType = self::contentTypes['getSpendingStat'][0])
    {
        $returnType = '\TextMagic\Models\GetSpendingStatPaginatedResponse';
        $request = $this->getSpendingStatRequest($page, $limit, $start, $end, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpendingStat'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $start Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. (optional)
     * @param  string|null $end Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpendingStat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpendingStatRequest($page = 1, $limit = 10, $start = null, $end = null, string $contentType = self::contentTypes['getSpendingStat'][0])
    {






        $resourcePath = '/api/v2/stats/spending';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplate
     *
     * Get a template&#x60;s details
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\MessageTemplate|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getTemplate($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        list($response) = $this->getTemplateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getTemplateWithHttpInfo
     *
     * Get a template&#x60;s details
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\MessageTemplate|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateWithHttpInfo($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $request = $this->getTemplateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\MessageTemplate',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\MessageTemplate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\MessageTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTemplateAsync
     *
     * Get a template&#x60;s details
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsync($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        return $this->getTemplateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateAsyncWithHttpInfo
     *
     * Get a template&#x60;s details
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $returnType = '\TextMagic\Models\MessageTemplate';
        $request = $this->getTemplateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplate'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplateRequest($id, string $contentType = self::contentTypes['getTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTemplate'
            );
        }


        $resourcePath = '/api/v2/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnreadMessagesTotal
     *
     * Get unread messages number
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnreadMessagesTotal'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetUnreadMessagesTotalResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getUnreadMessagesTotal(string $contentType = self::contentTypes['getUnreadMessagesTotal'][0])
    {
        list($response) = $this->getUnreadMessagesTotalWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getUnreadMessagesTotalWithHttpInfo
     *
     * Get unread messages number
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnreadMessagesTotal'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetUnreadMessagesTotalResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnreadMessagesTotalWithHttpInfo(string $contentType = self::contentTypes['getUnreadMessagesTotal'][0])
    {
        $request = $this->getUnreadMessagesTotalRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetUnreadMessagesTotalResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetUnreadMessagesTotalResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetUnreadMessagesTotalResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUnreadMessagesTotalAsync
     *
     * Get unread messages number
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnreadMessagesTotal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnreadMessagesTotalAsync(string $contentType = self::contentTypes['getUnreadMessagesTotal'][0])
    {
        return $this->getUnreadMessagesTotalAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnreadMessagesTotalAsyncWithHttpInfo
     *
     * Get unread messages number
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnreadMessagesTotal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnreadMessagesTotalAsyncWithHttpInfo(string $contentType = self::contentTypes['getUnreadMessagesTotal'][0])
    {
        $returnType = '\TextMagic\Models\GetUnreadMessagesTotalResponse';
        $request = $this->getUnreadMessagesTotalRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnreadMessagesTotal'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnreadMessagesTotal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUnreadMessagesTotalRequest(string $contentType = self::contentTypes['getUnreadMessagesTotal'][0])
    {


        $resourcePath = '/api/v2/chats/unread/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnsubscribedContact
     *
     * Get the details of a specific unsubscribed contact
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribedContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UnsubscribedContact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getUnsubscribedContact($id, string $contentType = self::contentTypes['getUnsubscribedContact'][0])
    {
        list($response) = $this->getUnsubscribedContactWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getUnsubscribedContactWithHttpInfo
     *
     * Get the details of a specific unsubscribed contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribedContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UnsubscribedContact|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnsubscribedContactWithHttpInfo($id, string $contentType = self::contentTypes['getUnsubscribedContact'][0])
    {
        $request = $this->getUnsubscribedContactRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnsubscribedContact',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UnsubscribedContact',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnsubscribedContact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUnsubscribedContactAsync
     *
     * Get the details of a specific unsubscribed contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribedContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnsubscribedContactAsync($id, string $contentType = self::contentTypes['getUnsubscribedContact'][0])
    {
        return $this->getUnsubscribedContactAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnsubscribedContactAsyncWithHttpInfo
     *
     * Get the details of a specific unsubscribed contact
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribedContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnsubscribedContactAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getUnsubscribedContact'][0])
    {
        $returnType = '\TextMagic\Models\UnsubscribedContact';
        $request = $this->getUnsubscribedContactRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnsubscribedContact'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribedContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUnsubscribedContactRequest($id, string $contentType = self::contentTypes['getUnsubscribedContact'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getUnsubscribedContact'
            );
        }


        $resourcePath = '/api/v2/unsubscribers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnsubscribers
     *
     * Get all unsubscribed contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetUnsubscribersPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function getUnsubscribers($page = 1, $limit = 10, string $contentType = self::contentTypes['getUnsubscribers'][0])
    {
        list($response) = $this->getUnsubscribersWithHttpInfo($page, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getUnsubscribersWithHttpInfo
     *
     * Get all unsubscribed contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetUnsubscribersPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnsubscribersWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getUnsubscribers'][0])
    {
        $request = $this->getUnsubscribersRequest($page, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetUnsubscribersPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetUnsubscribersPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetUnsubscribersPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUnsubscribersAsync
     *
     * Get all unsubscribed contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnsubscribersAsync($page = 1, $limit = 10, string $contentType = self::contentTypes['getUnsubscribers'][0])
    {
        return $this->getUnsubscribersAsyncWithHttpInfo($page, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnsubscribersAsyncWithHttpInfo
     *
     * Get all unsubscribed contacts
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnsubscribersAsyncWithHttpInfo($page = 1, $limit = 10, string $contentType = self::contentTypes['getUnsubscribers'][0])
    {
        $returnType = '\TextMagic\Models\GetUnsubscribersPaginatedResponse';
        $request = $this->getUnsubscribersRequest($page, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnsubscribers'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUnsubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUnsubscribersRequest($page = 1, $limit = 10, string $contentType = self::contentTypes['getUnsubscribers'][0])
    {




        $resourcePath = '/api/v2/unsubscribers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserDedicatedNumbers
     *
     * Get all your dedicated numbers
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $surveyId Fetch only those numbers that are ready for the survey. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function getUserDedicatedNumbers($page = 1, $limit = 10, $surveyId = null, string $contentType = self::contentTypes['getUserDedicatedNumbers'][0])
    {
        list($response) = $this->getUserDedicatedNumbersWithHttpInfo($page, $limit, $surveyId, $contentType);
        return $response;
    }

    /**
     * Operation getUserDedicatedNumbersWithHttpInfo
     *
     * Get all your dedicated numbers
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $surveyId Fetch only those numbers that are ready for the survey. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserDedicatedNumbersWithHttpInfo($page = 1, $limit = 10, $surveyId = null, string $contentType = self::contentTypes['getUserDedicatedNumbers'][0])
    {
        $request = $this->getUserDedicatedNumbersRequest($page, $limit, $surveyId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserDedicatedNumbersAsync
     *
     * Get all your dedicated numbers
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $surveyId Fetch only those numbers that are ready for the survey. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserDedicatedNumbersAsync($page = 1, $limit = 10, $surveyId = null, string $contentType = self::contentTypes['getUserDedicatedNumbers'][0])
    {
        return $this->getUserDedicatedNumbersAsyncWithHttpInfo($page, $limit, $surveyId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserDedicatedNumbersAsyncWithHttpInfo
     *
     * Get all your dedicated numbers
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $surveyId Fetch only those numbers that are ready for the survey. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserDedicatedNumbersAsyncWithHttpInfo($page = 1, $limit = 10, $surveyId = null, string $contentType = self::contentTypes['getUserDedicatedNumbers'][0])
    {
        $returnType = '\TextMagic\Models\GetUserDedicatedNumbersPaginatedResponse';
        $request = $this->getUserDedicatedNumbersRequest($page, $limit, $surveyId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserDedicatedNumbers'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $surveyId Fetch only those numbers that are ready for the survey. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserDedicatedNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserDedicatedNumbersRequest($page = 1, $limit = 10, $surveyId = null, string $contentType = self::contentTypes['getUserDedicatedNumbers'][0])
    {





        $resourcePath = '/api/v2/numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $surveyId,
            'surveyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importContacts
     *
     * Import contacts
     *
     * @param  string $column Import file column mapping. The string must contain sub-strings of mapping in format &#x60;columnNumber:field&#x60; glued by &#x60;;&#x60;. For example: &#x60;0:firstName;1:lastName;3:phone;4:email&#x60; where the value before &#x60;:&#x60; is a number of the column in the file, and the value after &#x60;:&#x60; is a field of the newly created contact or the ID of a custom field. Numbers of columns begin from zero. Allowed built-in contact fields are: &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;phone&#x60;, &#x60;email&#x60;. Existing of &#x60;phone&#x60; mapping is required. (required)
     * @param  \SplFileObject $file File containing contacts in csv or xls(x) formats. (required)
     * @param  int|null $listId List that ID contacts will be imported to. Ignored if &#x60;listName&#x60; is specified. (optional)
     * @param  string|null $listName List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if &#x60;listId&#x60; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function importContacts($column, $file, $listId = null, $listName = null, string $contentType = self::contentTypes['importContacts'][0])
    {
        list($response) = $this->importContactsWithHttpInfo($column, $file, $listId, $listName, $contentType);
        return $response;
    }

    /**
     * Operation importContactsWithHttpInfo
     *
     * Import contacts
     *
     * @param  string $column Import file column mapping. The string must contain sub-strings of mapping in format &#x60;columnNumber:field&#x60; glued by &#x60;;&#x60;. For example: &#x60;0:firstName;1:lastName;3:phone;4:email&#x60; where the value before &#x60;:&#x60; is a number of the column in the file, and the value after &#x60;:&#x60; is a field of the newly created contact or the ID of a custom field. Numbers of columns begin from zero. Allowed built-in contact fields are: &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;phone&#x60;, &#x60;email&#x60;. Existing of &#x60;phone&#x60; mapping is required. (required)
     * @param  \SplFileObject $file File containing contacts in csv or xls(x) formats. (required)
     * @param  int|null $listId List that ID contacts will be imported to. Ignored if &#x60;listName&#x60; is specified. (optional)
     * @param  string|null $listName List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if &#x60;listId&#x60; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importContactsWithHttpInfo($column, $file, $listId = null, $listName = null, string $contentType = self::contentTypes['importContacts'][0])
    {
        $request = $this->importContactsRequest($column, $file, $listId, $listName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation importContactsAsync
     *
     * Import contacts
     *
     * @param  string $column Import file column mapping. The string must contain sub-strings of mapping in format &#x60;columnNumber:field&#x60; glued by &#x60;;&#x60;. For example: &#x60;0:firstName;1:lastName;3:phone;4:email&#x60; where the value before &#x60;:&#x60; is a number of the column in the file, and the value after &#x60;:&#x60; is a field of the newly created contact or the ID of a custom field. Numbers of columns begin from zero. Allowed built-in contact fields are: &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;phone&#x60;, &#x60;email&#x60;. Existing of &#x60;phone&#x60; mapping is required. (required)
     * @param  \SplFileObject $file File containing contacts in csv or xls(x) formats. (required)
     * @param  int|null $listId List that ID contacts will be imported to. Ignored if &#x60;listName&#x60; is specified. (optional)
     * @param  string|null $listName List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if &#x60;listId&#x60; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importContactsAsync($column, $file, $listId = null, $listName = null, string $contentType = self::contentTypes['importContacts'][0])
    {
        return $this->importContactsAsyncWithHttpInfo($column, $file, $listId, $listName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importContactsAsyncWithHttpInfo
     *
     * Import contacts
     *
     * @param  string $column Import file column mapping. The string must contain sub-strings of mapping in format &#x60;columnNumber:field&#x60; glued by &#x60;;&#x60;. For example: &#x60;0:firstName;1:lastName;3:phone;4:email&#x60; where the value before &#x60;:&#x60; is a number of the column in the file, and the value after &#x60;:&#x60; is a field of the newly created contact or the ID of a custom field. Numbers of columns begin from zero. Allowed built-in contact fields are: &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;phone&#x60;, &#x60;email&#x60;. Existing of &#x60;phone&#x60; mapping is required. (required)
     * @param  \SplFileObject $file File containing contacts in csv or xls(x) formats. (required)
     * @param  int|null $listId List that ID contacts will be imported to. Ignored if &#x60;listName&#x60; is specified. (optional)
     * @param  string|null $listName List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if &#x60;listId&#x60; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importContactsAsyncWithHttpInfo($column, $file, $listId = null, $listName = null, string $contentType = self::contentTypes['importContacts'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->importContactsRequest($column, $file, $listId, $listName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importContacts'
     *
     * @param  string $column Import file column mapping. The string must contain sub-strings of mapping in format &#x60;columnNumber:field&#x60; glued by &#x60;;&#x60;. For example: &#x60;0:firstName;1:lastName;3:phone;4:email&#x60; where the value before &#x60;:&#x60; is a number of the column in the file, and the value after &#x60;:&#x60; is a field of the newly created contact or the ID of a custom field. Numbers of columns begin from zero. Allowed built-in contact fields are: &#x60;firstName&#x60;, &#x60;lastName&#x60;, &#x60;phone&#x60;, &#x60;email&#x60;. Existing of &#x60;phone&#x60; mapping is required. (required)
     * @param  \SplFileObject $file File containing contacts in csv or xls(x) formats. (required)
     * @param  int|null $listId List that ID contacts will be imported to. Ignored if &#x60;listName&#x60; is specified. (optional)
     * @param  string|null $listName List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if &#x60;listId&#x60; is specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importContactsRequest($column, $file, $listId = null, $listName = null, string $contentType = self::contentTypes['importContacts'][0])
    {

        // verify the required parameter 'column' is set
        if ($column === null || (is_array($column) && count($column) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $column when calling importContacts'
            );
        }

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling importContacts'
            );
        }




        $resourcePath = '/api/v2/contacts/import/normalized';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $column,
            'column', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listId,
            'listId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listName,
            'listName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);



        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markChatsReadBulk
     *
     * Mark chats as read (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsReadBulkInputObject markChatsReadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsReadBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function markChatsReadBulk($markChatsReadBulkInputObject, string $contentType = self::contentTypes['markChatsReadBulk'][0])
    {
        $this->markChatsReadBulkWithHttpInfo($markChatsReadBulkInputObject, $contentType);
    }

    /**
     * Operation markChatsReadBulkWithHttpInfo
     *
     * Mark chats as read (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsReadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsReadBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markChatsReadBulkWithHttpInfo($markChatsReadBulkInputObject, string $contentType = self::contentTypes['markChatsReadBulk'][0])
    {
        $request = $this->markChatsReadBulkRequest($markChatsReadBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation markChatsReadBulkAsync
     *
     * Mark chats as read (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsReadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsReadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChatsReadBulkAsync($markChatsReadBulkInputObject, string $contentType = self::contentTypes['markChatsReadBulk'][0])
    {
        return $this->markChatsReadBulkAsyncWithHttpInfo($markChatsReadBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markChatsReadBulkAsyncWithHttpInfo
     *
     * Mark chats as read (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsReadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsReadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChatsReadBulkAsyncWithHttpInfo($markChatsReadBulkInputObject, string $contentType = self::contentTypes['markChatsReadBulk'][0])
    {
        $returnType = '';
        $request = $this->markChatsReadBulkRequest($markChatsReadBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markChatsReadBulk'
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsReadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsReadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markChatsReadBulkRequest($markChatsReadBulkInputObject, string $contentType = self::contentTypes['markChatsReadBulk'][0])
    {

        // verify the required parameter 'markChatsReadBulkInputObject' is set
        if ($markChatsReadBulkInputObject === null || (is_array($markChatsReadBulkInputObject) && count($markChatsReadBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $markChatsReadBulkInputObject when calling markChatsReadBulk'
            );
        }


        $resourcePath = '/api/v2/chats/read/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($markChatsReadBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($markChatsReadBulkInputObject));
            } else {
                $httpBody = $markChatsReadBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markChatsUnreadBulk
     *
     * Mark chats as unread (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsUnreadBulkInputObject markChatsUnreadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsUnreadBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function markChatsUnreadBulk($markChatsUnreadBulkInputObject, string $contentType = self::contentTypes['markChatsUnreadBulk'][0])
    {
        $this->markChatsUnreadBulkWithHttpInfo($markChatsUnreadBulkInputObject, $contentType);
    }

    /**
     * Operation markChatsUnreadBulkWithHttpInfo
     *
     * Mark chats as unread (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsUnreadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsUnreadBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markChatsUnreadBulkWithHttpInfo($markChatsUnreadBulkInputObject, string $contentType = self::contentTypes['markChatsUnreadBulk'][0])
    {
        $request = $this->markChatsUnreadBulkRequest($markChatsUnreadBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation markChatsUnreadBulkAsync
     *
     * Mark chats as unread (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsUnreadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsUnreadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChatsUnreadBulkAsync($markChatsUnreadBulkInputObject, string $contentType = self::contentTypes['markChatsUnreadBulk'][0])
    {
        return $this->markChatsUnreadBulkAsyncWithHttpInfo($markChatsUnreadBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markChatsUnreadBulkAsyncWithHttpInfo
     *
     * Mark chats as unread (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsUnreadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsUnreadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markChatsUnreadBulkAsyncWithHttpInfo($markChatsUnreadBulkInputObject, string $contentType = self::contentTypes['markChatsUnreadBulk'][0])
    {
        $returnType = '';
        $request = $this->markChatsUnreadBulkRequest($markChatsUnreadBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markChatsUnreadBulk'
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $markChatsUnreadBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markChatsUnreadBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markChatsUnreadBulkRequest($markChatsUnreadBulkInputObject, string $contentType = self::contentTypes['markChatsUnreadBulk'][0])
    {

        // verify the required parameter 'markChatsUnreadBulkInputObject' is set
        if ($markChatsUnreadBulkInputObject === null || (is_array($markChatsUnreadBulkInputObject) && count($markChatsUnreadBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $markChatsUnreadBulkInputObject when calling markChatsUnreadBulk'
            );
        }


        $resourcePath = '/api/v2/chats/unread/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($markChatsUnreadBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($markChatsUnreadBulkInputObject));
            } else {
                $httpBody = $markChatsUnreadBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation muteChat
     *
     * Mute chat sounds
     *
     * @param  \TextMagic\Models\MuteChatRequest $muteChatInputObject muteChatInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function muteChat($muteChatInputObject, string $contentType = self::contentTypes['muteChat'][0])
    {
        list($response) = $this->muteChatWithHttpInfo($muteChatInputObject, $contentType);
        return $response;
    }

    /**
     * Operation muteChatWithHttpInfo
     *
     * Mute chat sounds
     *
     * @param  \TextMagic\Models\MuteChatRequest $muteChatInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChat'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function muteChatWithHttpInfo($muteChatInputObject, string $contentType = self::contentTypes['muteChat'][0])
    {
        $request = $this->muteChatRequest($muteChatInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation muteChatAsync
     *
     * Mute chat sounds
     *
     * @param  \TextMagic\Models\MuteChatRequest $muteChatInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteChatAsync($muteChatInputObject, string $contentType = self::contentTypes['muteChat'][0])
    {
        return $this->muteChatAsyncWithHttpInfo($muteChatInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation muteChatAsyncWithHttpInfo
     *
     * Mute chat sounds
     *
     * @param  \TextMagic\Models\MuteChatRequest $muteChatInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteChatAsyncWithHttpInfo($muteChatInputObject, string $contentType = self::contentTypes['muteChat'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->muteChatRequest($muteChatInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'muteChat'
     *
     * @param  \TextMagic\Models\MuteChatRequest $muteChatInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function muteChatRequest($muteChatInputObject, string $contentType = self::contentTypes['muteChat'][0])
    {

        // verify the required parameter 'muteChatInputObject' is set
        if ($muteChatInputObject === null || (is_array($muteChatInputObject) && count($muteChatInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $muteChatInputObject when calling muteChat'
            );
        }


        $resourcePath = '/api/v2/chats/mute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($muteChatInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($muteChatInputObject));
            } else {
                $httpBody = $muteChatInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation muteChatsBulk
     *
     * Mute chats (bulk)
     *
     * @param  \TextMagic\Models\MuteChatsBulkRequest $muteChatsBulkInputObject muteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function muteChatsBulk($muteChatsBulkInputObject, string $contentType = self::contentTypes['muteChatsBulk'][0])
    {
        $this->muteChatsBulkWithHttpInfo($muteChatsBulkInputObject, $contentType);
    }

    /**
     * Operation muteChatsBulkWithHttpInfo
     *
     * Mute chats (bulk)
     *
     * @param  \TextMagic\Models\MuteChatsBulkRequest $muteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function muteChatsBulkWithHttpInfo($muteChatsBulkInputObject, string $contentType = self::contentTypes['muteChatsBulk'][0])
    {
        $request = $this->muteChatsBulkRequest($muteChatsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation muteChatsBulkAsync
     *
     * Mute chats (bulk)
     *
     * @param  \TextMagic\Models\MuteChatsBulkRequest $muteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteChatsBulkAsync($muteChatsBulkInputObject, string $contentType = self::contentTypes['muteChatsBulk'][0])
    {
        return $this->muteChatsBulkAsyncWithHttpInfo($muteChatsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation muteChatsBulkAsyncWithHttpInfo
     *
     * Mute chats (bulk)
     *
     * @param  \TextMagic\Models\MuteChatsBulkRequest $muteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteChatsBulkAsyncWithHttpInfo($muteChatsBulkInputObject, string $contentType = self::contentTypes['muteChatsBulk'][0])
    {
        $returnType = '';
        $request = $this->muteChatsBulkRequest($muteChatsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'muteChatsBulk'
     *
     * @param  \TextMagic\Models\MuteChatsBulkRequest $muteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['muteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function muteChatsBulkRequest($muteChatsBulkInputObject, string $contentType = self::contentTypes['muteChatsBulk'][0])
    {

        // verify the required parameter 'muteChatsBulkInputObject' is set
        if ($muteChatsBulkInputObject === null || (is_array($muteChatsBulkInputObject) && count($muteChatsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $muteChatsBulkInputObject when calling muteChatsBulk'
            );
        }


        $resourcePath = '/api/v2/chats/mute/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($muteChatsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($muteChatsBulkInputObject));
            } else {
                $httpBody = $muteChatsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ping
     *
     * Ping
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ping'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\PingResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function ping(string $contentType = self::contentTypes['ping'][0])
    {
        list($response) = $this->pingWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation pingWithHttpInfo
     *
     * Ping
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ping'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\PingResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pingWithHttpInfo(string $contentType = self::contentTypes['ping'][0])
    {
        $request = $this->pingRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\PingResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\PingResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\PingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation pingAsync
     *
     * Ping
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pingAsync(string $contentType = self::contentTypes['ping'][0])
    {
        return $this->pingAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pingAsyncWithHttpInfo
     *
     * Ping
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pingAsyncWithHttpInfo(string $contentType = self::contentTypes['ping'][0])
    {
        $returnType = '\TextMagic\Models\PingResponse';
        $request = $this->pingRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ping'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pingRequest(string $contentType = self::contentTypes['ping'][0])
    {


        $resourcePath = '/api/v2/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reopenChatsBulk
     *
     * Reopen chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $reopenChatsBulkInputObject reopenChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reopenChatsBulk($reopenChatsBulkInputObject, string $contentType = self::contentTypes['reopenChatsBulk'][0])
    {
        $this->reopenChatsBulkWithHttpInfo($reopenChatsBulkInputObject, $contentType);
    }

    /**
     * Operation reopenChatsBulkWithHttpInfo
     *
     * Reopen chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $reopenChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reopenChatsBulkWithHttpInfo($reopenChatsBulkInputObject, string $contentType = self::contentTypes['reopenChatsBulk'][0])
    {
        $request = $this->reopenChatsBulkRequest($reopenChatsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation reopenChatsBulkAsync
     *
     * Reopen chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $reopenChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenChatsBulkAsync($reopenChatsBulkInputObject, string $contentType = self::contentTypes['reopenChatsBulk'][0])
    {
        return $this->reopenChatsBulkAsyncWithHttpInfo($reopenChatsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reopenChatsBulkAsyncWithHttpInfo
     *
     * Reopen chats (bulk)
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $reopenChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenChatsBulkAsyncWithHttpInfo($reopenChatsBulkInputObject, string $contentType = self::contentTypes['reopenChatsBulk'][0])
    {
        $returnType = '';
        $request = $this->reopenChatsBulkRequest($reopenChatsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reopenChatsBulk'
     *
     * @param  \TextMagic\Models\MarkChatsUnreadBulkRequest $reopenChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reopenChatsBulkRequest($reopenChatsBulkInputObject, string $contentType = self::contentTypes['reopenChatsBulk'][0])
    {

        // verify the required parameter 'reopenChatsBulkInputObject' is set
        if ($reopenChatsBulkInputObject === null || (is_array($reopenChatsBulkInputObject) && count($reopenChatsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reopenChatsBulkInputObject when calling reopenChatsBulk'
            );
        }


        $resourcePath = '/api/v2/chats/reopen/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reopenChatsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reopenChatsBulkInputObject));
            } else {
                $httpBody = $reopenChatsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestSenderId
     *
     * Apply for a new Sender ID
     *
     * @param  \TextMagic\Models\RequestSenderIdRequest $requestSenderIdInputObject requestSenderIdInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function requestSenderId($requestSenderIdInputObject, string $contentType = self::contentTypes['requestSenderId'][0])
    {
        list($response) = $this->requestSenderIdWithHttpInfo($requestSenderIdInputObject, $contentType);
        return $response;
    }

    /**
     * Operation requestSenderIdWithHttpInfo
     *
     * Apply for a new Sender ID
     *
     * @param  \TextMagic\Models\RequestSenderIdRequest $requestSenderIdInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestSenderId'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestSenderIdWithHttpInfo($requestSenderIdInputObject, string $contentType = self::contentTypes['requestSenderId'][0])
    {
        $request = $this->requestSenderIdRequest($requestSenderIdInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation requestSenderIdAsync
     *
     * Apply for a new Sender ID
     *
     * @param  \TextMagic\Models\RequestSenderIdRequest $requestSenderIdInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestSenderIdAsync($requestSenderIdInputObject, string $contentType = self::contentTypes['requestSenderId'][0])
    {
        return $this->requestSenderIdAsyncWithHttpInfo($requestSenderIdInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestSenderIdAsyncWithHttpInfo
     *
     * Apply for a new Sender ID
     *
     * @param  \TextMagic\Models\RequestSenderIdRequest $requestSenderIdInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestSenderIdAsyncWithHttpInfo($requestSenderIdInputObject, string $contentType = self::contentTypes['requestSenderId'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->requestSenderIdRequest($requestSenderIdInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestSenderId'
     *
     * @param  \TextMagic\Models\RequestSenderIdRequest $requestSenderIdInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestSenderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestSenderIdRequest($requestSenderIdInputObject, string $contentType = self::contentTypes['requestSenderId'][0])
    {

        // verify the required parameter 'requestSenderIdInputObject' is set
        if ($requestSenderIdInputObject === null || (is_array($requestSenderIdInputObject) && count($requestSenderIdInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestSenderIdInputObject when calling requestSenderId'
            );
        }


        $resourcePath = '/api/v2/senderids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestSenderIdInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestSenderIdInputObject));
            } else {
                $httpBody = $requestSenderIdInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleEmailCampaign
     *
     * Schedule new email campaign
     *
     * @param  \TextMagic\Models\ScheduleEmailCampaignRequest $scheduleEmailCampaignInputObject scheduleEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleEmailCampaign'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ScheduleEmailCampaignResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function scheduleEmailCampaign($scheduleEmailCampaignInputObject, string $contentType = self::contentTypes['scheduleEmailCampaign'][0])
    {
        list($response) = $this->scheduleEmailCampaignWithHttpInfo($scheduleEmailCampaignInputObject, $contentType);
        return $response;
    }

    /**
     * Operation scheduleEmailCampaignWithHttpInfo
     *
     * Schedule new email campaign
     *
     * @param  \TextMagic\Models\ScheduleEmailCampaignRequest $scheduleEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleEmailCampaign'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ScheduleEmailCampaignResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleEmailCampaignWithHttpInfo($scheduleEmailCampaignInputObject, string $contentType = self::contentTypes['scheduleEmailCampaign'][0])
    {
        $request = $this->scheduleEmailCampaignRequest($scheduleEmailCampaignInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ScheduleEmailCampaignResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ScheduleEmailCampaignResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ScheduleEmailCampaignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation scheduleEmailCampaignAsync
     *
     * Schedule new email campaign
     *
     * @param  \TextMagic\Models\ScheduleEmailCampaignRequest $scheduleEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleEmailCampaignAsync($scheduleEmailCampaignInputObject, string $contentType = self::contentTypes['scheduleEmailCampaign'][0])
    {
        return $this->scheduleEmailCampaignAsyncWithHttpInfo($scheduleEmailCampaignInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleEmailCampaignAsyncWithHttpInfo
     *
     * Schedule new email campaign
     *
     * @param  \TextMagic\Models\ScheduleEmailCampaignRequest $scheduleEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleEmailCampaignAsyncWithHttpInfo($scheduleEmailCampaignInputObject, string $contentType = self::contentTypes['scheduleEmailCampaign'][0])
    {
        $returnType = '\TextMagic\Models\ScheduleEmailCampaignResponse';
        $request = $this->scheduleEmailCampaignRequest($scheduleEmailCampaignInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleEmailCampaign'
     *
     * @param  \TextMagic\Models\ScheduleEmailCampaignRequest $scheduleEmailCampaignInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleEmailCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scheduleEmailCampaignRequest($scheduleEmailCampaignInputObject, string $contentType = self::contentTypes['scheduleEmailCampaign'][0])
    {

        // verify the required parameter 'scheduleEmailCampaignInputObject' is set
        if ($scheduleEmailCampaignInputObject === null || (is_array($scheduleEmailCampaignInputObject) && count($scheduleEmailCampaignInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduleEmailCampaignInputObject when calling scheduleEmailCampaign'
            );
        }


        $resourcePath = '/api/v2/email-campaigns/schedule';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($scheduleEmailCampaignInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($scheduleEmailCampaignInputObject));
            } else {
                $httpBody = $scheduleEmailCampaignInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchChats
     *
     * Find chats by message text
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchChatsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchChats($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['searchChats'][0])
    {
        list($response) = $this->searchChatsWithHttpInfo($page, $limit, $query, $contentType);
        return $response;
    }

    /**
     * Operation searchChatsWithHttpInfo
     *
     * Find chats by message text
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChats'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchChatsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchChatsWithHttpInfo($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['searchChats'][0])
    {
        $request = $this->searchChatsRequest($page, $limit, $query, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchChatsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchChatsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchChatsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchChatsAsync
     *
     * Find chats by message text
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsAsync($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['searchChats'][0])
    {
        return $this->searchChatsAsyncWithHttpInfo($page, $limit, $query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchChatsAsyncWithHttpInfo
     *
     * Find chats by message text
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsAsyncWithHttpInfo($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['searchChats'][0])
    {
        $returnType = '\TextMagic\Models\SearchChatsPaginatedResponse';
        $request = $this->searchChatsRequest($page, $limit, $query, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchChats'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchChatsRequest($page = 1, $limit = 10, $query = null, string $contentType = self::contentTypes['searchChats'][0])
    {





        $resourcePath = '/api/v2/chats/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchChatsByIds
     *
     * Find chats (bulk)
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find chats by ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchChatsByIdsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchChatsByIds($page = 1, $limit = 10, $ids = null, string $contentType = self::contentTypes['searchChatsByIds'][0])
    {
        list($response) = $this->searchChatsByIdsWithHttpInfo($page, $limit, $ids, $contentType);
        return $response;
    }

    /**
     * Operation searchChatsByIdsWithHttpInfo
     *
     * Find chats (bulk)
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find chats by ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByIds'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchChatsByIdsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchChatsByIdsWithHttpInfo($page = 1, $limit = 10, $ids = null, string $contentType = self::contentTypes['searchChatsByIds'][0])
    {
        $request = $this->searchChatsByIdsRequest($page, $limit, $ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchChatsByIdsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchChatsByIdsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchChatsByIdsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchChatsByIdsAsync
     *
     * Find chats (bulk)
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find chats by ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsByIdsAsync($page = 1, $limit = 10, $ids = null, string $contentType = self::contentTypes['searchChatsByIds'][0])
    {
        return $this->searchChatsByIdsAsyncWithHttpInfo($page, $limit, $ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchChatsByIdsAsyncWithHttpInfo
     *
     * Find chats (bulk)
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find chats by ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsByIdsAsyncWithHttpInfo($page = 1, $limit = 10, $ids = null, string $contentType = self::contentTypes['searchChatsByIds'][0])
    {
        $returnType = '\TextMagic\Models\SearchChatsByIdsPaginatedResponse';
        $request = $this->searchChatsByIdsRequest($page, $limit, $ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchChatsByIds'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find chats by ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchChatsByIdsRequest($page = 1, $limit = 10, $ids = null, string $contentType = self::contentTypes['searchChatsByIds'][0])
    {



        if ($ids !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling TextMagicApi.searchChatsByIds, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        

        $resourcePath = '/api/v2/chats/search/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchChatsByReceipent
     *
     * Find chats by recipient
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByReceipent'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchChatsByReceipentPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchChatsByReceipent($page = 1, $limit = 10, $query = null, $orderBy = 'id', string $contentType = self::contentTypes['searchChatsByReceipent'][0])
    {
        list($response) = $this->searchChatsByReceipentWithHttpInfo($page, $limit, $query, $orderBy, $contentType);
        return $response;
    }

    /**
     * Operation searchChatsByReceipentWithHttpInfo
     *
     * Find chats by recipient
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByReceipent'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchChatsByReceipentPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchChatsByReceipentWithHttpInfo($page = 1, $limit = 10, $query = null, $orderBy = 'id', string $contentType = self::contentTypes['searchChatsByReceipent'][0])
    {
        $request = $this->searchChatsByReceipentRequest($page, $limit, $query, $orderBy, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchChatsByReceipentPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchChatsByReceipentPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchChatsByReceipentPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchChatsByReceipentAsync
     *
     * Find chats by recipient
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByReceipent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsByReceipentAsync($page = 1, $limit = 10, $query = null, $orderBy = 'id', string $contentType = self::contentTypes['searchChatsByReceipent'][0])
    {
        return $this->searchChatsByReceipentAsyncWithHttpInfo($page, $limit, $query, $orderBy, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchChatsByReceipentAsyncWithHttpInfo
     *
     * Find chats by recipient
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByReceipent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchChatsByReceipentAsyncWithHttpInfo($page = 1, $limit = 10, $query = null, $orderBy = 'id', string $contentType = self::contentTypes['searchChatsByReceipent'][0])
    {
        $returnType = '\TextMagic\Models\SearchChatsByReceipentPaginatedResponse';
        $request = $this->searchChatsByReceipentRequest($page, $limit, $query, $orderBy, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchChatsByReceipent'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find chats by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchChatsByReceipent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchChatsByReceipentRequest($page = 1, $limit = 10, $query = null, $orderBy = 'id', string $contentType = self::contentTypes['searchChatsByReceipent'][0])
    {






        $resourcePath = '/api/v2/chats/search/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchContacts
     *
     * Find contacts by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $ids Find contacts by IDs. (optional)
     * @param  int|null $listId Find contacts by List ID. (optional)
     * @param  int|null $includeBlocked Should blocked contacts be included? (optional)
     * @param  string|null $query Find contacts by specified search query. (optional)
     * @param  int|null $local Treat phone number passed in the \&quot;query\&quot; field as local. Default is 0. (optional, default to 0)
     * @param  int|null $exactMatch Return only exactly matching contacts. Default is 0. (optional, default to 0)
     * @param  string|null $country The 2-letter ISO country code for local phone numbers, used when \&quot;local\&quot; is set to true. Default is the account country. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string|null $tagIds Find contacts by tag ID(s). Multiple IDs can be separated by comma. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchContacts($page = 1, $limit = 10, $shared = 0, $ids = null, $listId = null, $includeBlocked = null, $query = null, $local = 0, $exactMatch = 0, $country = null, $orderBy = 'id', $direction = 'desc', $tagIds = null, string $contentType = self::contentTypes['searchContacts'][0])
    {
        list($response) = $this->searchContactsWithHttpInfo($page, $limit, $shared, $ids, $listId, $includeBlocked, $query, $local, $exactMatch, $country, $orderBy, $direction, $tagIds, $contentType);
        return $response;
    }

    /**
     * Operation searchContactsWithHttpInfo
     *
     * Find contacts by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $ids Find contacts by IDs. (optional)
     * @param  int|null $listId Find contacts by List ID. (optional)
     * @param  int|null $includeBlocked Should blocked contacts be included? (optional)
     * @param  string|null $query Find contacts by specified search query. (optional)
     * @param  int|null $local Treat phone number passed in the \&quot;query\&quot; field as local. Default is 0. (optional, default to 0)
     * @param  int|null $exactMatch Return only exactly matching contacts. Default is 0. (optional, default to 0)
     * @param  string|null $country The 2-letter ISO country code for local phone numbers, used when \&quot;local\&quot; is set to true. Default is the account country. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string|null $tagIds Find contacts by tag ID(s). Multiple IDs can be separated by comma. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchContacts'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchContactsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchContactsWithHttpInfo($page = 1, $limit = 10, $shared = 0, $ids = null, $listId = null, $includeBlocked = null, $query = null, $local = 0, $exactMatch = 0, $country = null, $orderBy = 'id', $direction = 'desc', $tagIds = null, string $contentType = self::contentTypes['searchContacts'][0])
    {
        $request = $this->searchContactsRequest($page, $limit, $shared, $ids, $listId, $includeBlocked, $query, $local, $exactMatch, $country, $orderBy, $direction, $tagIds, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchContactsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchContactsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchContactsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchContactsAsync
     *
     * Find contacts by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $ids Find contacts by IDs. (optional)
     * @param  int|null $listId Find contacts by List ID. (optional)
     * @param  int|null $includeBlocked Should blocked contacts be included? (optional)
     * @param  string|null $query Find contacts by specified search query. (optional)
     * @param  int|null $local Treat phone number passed in the \&quot;query\&quot; field as local. Default is 0. (optional, default to 0)
     * @param  int|null $exactMatch Return only exactly matching contacts. Default is 0. (optional, default to 0)
     * @param  string|null $country The 2-letter ISO country code for local phone numbers, used when \&quot;local\&quot; is set to true. Default is the account country. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string|null $tagIds Find contacts by tag ID(s). Multiple IDs can be separated by comma. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContactsAsync($page = 1, $limit = 10, $shared = 0, $ids = null, $listId = null, $includeBlocked = null, $query = null, $local = 0, $exactMatch = 0, $country = null, $orderBy = 'id', $direction = 'desc', $tagIds = null, string $contentType = self::contentTypes['searchContacts'][0])
    {
        return $this->searchContactsAsyncWithHttpInfo($page, $limit, $shared, $ids, $listId, $includeBlocked, $query, $local, $exactMatch, $country, $orderBy, $direction, $tagIds, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchContactsAsyncWithHttpInfo
     *
     * Find contacts by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $ids Find contacts by IDs. (optional)
     * @param  int|null $listId Find contacts by List ID. (optional)
     * @param  int|null $includeBlocked Should blocked contacts be included? (optional)
     * @param  string|null $query Find contacts by specified search query. (optional)
     * @param  int|null $local Treat phone number passed in the \&quot;query\&quot; field as local. Default is 0. (optional, default to 0)
     * @param  int|null $exactMatch Return only exactly matching contacts. Default is 0. (optional, default to 0)
     * @param  string|null $country The 2-letter ISO country code for local phone numbers, used when \&quot;local\&quot; is set to true. Default is the account country. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string|null $tagIds Find contacts by tag ID(s). Multiple IDs can be separated by comma. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContactsAsyncWithHttpInfo($page = 1, $limit = 10, $shared = 0, $ids = null, $listId = null, $includeBlocked = null, $query = null, $local = 0, $exactMatch = 0, $country = null, $orderBy = 'id', $direction = 'desc', $tagIds = null, string $contentType = self::contentTypes['searchContacts'][0])
    {
        $returnType = '\TextMagic\Models\SearchContactsPaginatedResponse';
        $request = $this->searchContactsRequest($page, $limit, $shared, $ids, $listId, $includeBlocked, $query, $local, $exactMatch, $country, $orderBy, $direction, $tagIds, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchContacts'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $shared Should shared contacts be included? (optional, default to 0)
     * @param  string|null $ids Find contacts by IDs. (optional)
     * @param  int|null $listId Find contacts by List ID. (optional)
     * @param  int|null $includeBlocked Should blocked contacts be included? (optional)
     * @param  string|null $query Find contacts by specified search query. (optional)
     * @param  int|null $local Treat phone number passed in the \&quot;query\&quot; field as local. Default is 0. (optional, default to 0)
     * @param  int|null $exactMatch Return only exactly matching contacts. Default is 0. (optional, default to 0)
     * @param  string|null $country The 2-letter ISO country code for local phone numbers, used when \&quot;local\&quot; is set to true. Default is the account country. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string|null $tagIds Find contacts by tag ID(s). Multiple IDs can be separated by comma. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchContacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchContactsRequest($page = 1, $limit = 10, $shared = 0, $ids = null, $listId = null, $includeBlocked = null, $query = null, $local = 0, $exactMatch = 0, $country = null, $orderBy = 'id', $direction = 'desc', $tagIds = null, string $contentType = self::contentTypes['searchContacts'][0])
    {




        if ($ids !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling TextMagicApi.searchContacts, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        








        if ($tagIds !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $tagIds)) {
            throw new \InvalidArgumentException("invalid value for \"tagIds\" when calling TextMagicApi.searchContacts, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        

        $resourcePath = '/api/v2/contacts/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shared,
            'shared', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listId,
            'listId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeBlocked,
            'includeBlocked', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $local,
            'local', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exactMatch,
            'exactMatch', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tagIds,
            'tagIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchInboundMessages
     *
     * Find inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  string|null $query Find recipients by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $expand Expand by adding firstName, lastName and contactId. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchInboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchInboundMessages($page = 1, $limit = 10, $ids = null, $query = null, $orderBy = 'id', $direction = 'desc', $expand = 0, string $contentType = self::contentTypes['searchInboundMessages'][0])
    {
        list($response) = $this->searchInboundMessagesWithHttpInfo($page, $limit, $ids, $query, $orderBy, $direction, $expand, $contentType);
        return $response;
    }

    /**
     * Operation searchInboundMessagesWithHttpInfo
     *
     * Find inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  string|null $query Find recipients by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $expand Expand by adding firstName, lastName and contactId. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchInboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchInboundMessagesWithHttpInfo($page = 1, $limit = 10, $ids = null, $query = null, $orderBy = 'id', $direction = 'desc', $expand = 0, string $contentType = self::contentTypes['searchInboundMessages'][0])
    {
        $request = $this->searchInboundMessagesRequest($page, $limit, $ids, $query, $orderBy, $direction, $expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchInboundMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchInboundMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchInboundMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchInboundMessagesAsync
     *
     * Find inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  string|null $query Find recipients by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $expand Expand by adding firstName, lastName and contactId. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInboundMessagesAsync($page = 1, $limit = 10, $ids = null, $query = null, $orderBy = 'id', $direction = 'desc', $expand = 0, string $contentType = self::contentTypes['searchInboundMessages'][0])
    {
        return $this->searchInboundMessagesAsyncWithHttpInfo($page, $limit, $ids, $query, $orderBy, $direction, $expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchInboundMessagesAsyncWithHttpInfo
     *
     * Find inbound messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  string|null $query Find recipients by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $expand Expand by adding firstName, lastName and contactId. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInboundMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $ids = null, $query = null, $orderBy = 'id', $direction = 'desc', $expand = 0, string $contentType = self::contentTypes['searchInboundMessages'][0])
    {
        $returnType = '\TextMagic\Models\SearchInboundMessagesPaginatedResponse';
        $request = $this->searchInboundMessagesRequest($page, $limit, $ids, $query, $orderBy, $direction, $expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchInboundMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  string|null $query Find recipients by specified search query. (optional)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  int|null $expand Expand by adding firstName, lastName and contactId. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchInboundMessagesRequest($page = 1, $limit = 10, $ids = null, $query = null, $orderBy = 'id', $direction = 'desc', $expand = 0, string $contentType = self::contentTypes['searchInboundMessages'][0])
    {



        if ($ids !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling TextMagicApi.searchInboundMessages, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        





        $resourcePath = '/api/v2/replies/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchLists
     *
     * Find lists by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find lists by IDs. (optional)
     * @param  string|null $query Find lists by specified search query. (optional)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  int|null $onlyDefault Return only default lists. (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchLists'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchListsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function searchLists($page = 1, $limit = 10, $ids = null, $query = null, $onlyMine = 0, $onlyDefault = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchLists'][0])
    {
        list($response) = $this->searchListsWithHttpInfo($page, $limit, $ids, $query, $onlyMine, $onlyDefault, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation searchListsWithHttpInfo
     *
     * Find lists by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find lists by IDs. (optional)
     * @param  string|null $query Find lists by specified search query. (optional)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  int|null $onlyDefault Return only default lists. (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchLists'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchListsPaginatedResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchListsWithHttpInfo($page = 1, $limit = 10, $ids = null, $query = null, $onlyMine = 0, $onlyDefault = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchLists'][0])
    {
        $request = $this->searchListsRequest($page, $limit, $ids, $query, $onlyMine, $onlyDefault, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchListsPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchListsPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchListsPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchListsAsync
     *
     * Find lists by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find lists by IDs. (optional)
     * @param  string|null $query Find lists by specified search query. (optional)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  int|null $onlyDefault Return only default lists. (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchListsAsync($page = 1, $limit = 10, $ids = null, $query = null, $onlyMine = 0, $onlyDefault = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchLists'][0])
    {
        return $this->searchListsAsyncWithHttpInfo($page, $limit, $ids, $query, $onlyMine, $onlyDefault, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchListsAsyncWithHttpInfo
     *
     * Find lists by given criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find lists by IDs. (optional)
     * @param  string|null $query Find lists by specified search query. (optional)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  int|null $onlyDefault Return only default lists. (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchListsAsyncWithHttpInfo($page = 1, $limit = 10, $ids = null, $query = null, $onlyMine = 0, $onlyDefault = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchLists'][0])
    {
        $returnType = '\TextMagic\Models\SearchListsPaginatedResponse';
        $request = $this->searchListsRequest($page, $limit, $ids, $query, $onlyMine, $onlyDefault, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchLists'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find lists by IDs. (optional)
     * @param  string|null $query Find lists by specified search query. (optional)
     * @param  int|null $onlyMine Return only current user lists. (optional, default to 0)
     * @param  int|null $onlyDefault Return only default lists. (optional, default to 0)
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchListsRequest($page = 1, $limit = 10, $ids = null, $query = null, $onlyMine = 0, $onlyDefault = 0, $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchLists'][0])
    {










        $resourcePath = '/api/v2/lists/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyMine,
            'onlyMine', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyDefault,
            'onlyDefault', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchOutboundMessages
     *
     * Find messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  int|null $sessionId Find messages by session ID. (optional)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchOutboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchOutboundMessages($page = 1, $limit = 10, $lastId = null, $ids = null, $sessionId = null, $statuses = null, $includeDeleted = 0, $query = null, string $contentType = self::contentTypes['searchOutboundMessages'][0])
    {
        list($response) = $this->searchOutboundMessagesWithHttpInfo($page, $limit, $lastId, $ids, $sessionId, $statuses, $includeDeleted, $query, $contentType);
        return $response;
    }

    /**
     * Operation searchOutboundMessagesWithHttpInfo
     *
     * Find messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  int|null $sessionId Find messages by session ID. (optional)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchOutboundMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchOutboundMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchOutboundMessagesWithHttpInfo($page = 1, $limit = 10, $lastId = null, $ids = null, $sessionId = null, $statuses = null, $includeDeleted = 0, $query = null, string $contentType = self::contentTypes['searchOutboundMessages'][0])
    {
        $request = $this->searchOutboundMessagesRequest($page, $limit, $lastId, $ids, $sessionId, $statuses, $includeDeleted, $query, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchOutboundMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchOutboundMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchOutboundMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchOutboundMessagesAsync
     *
     * Find messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  int|null $sessionId Find messages by session ID. (optional)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchOutboundMessagesAsync($page = 1, $limit = 10, $lastId = null, $ids = null, $sessionId = null, $statuses = null, $includeDeleted = 0, $query = null, string $contentType = self::contentTypes['searchOutboundMessages'][0])
    {
        return $this->searchOutboundMessagesAsyncWithHttpInfo($page, $limit, $lastId, $ids, $sessionId, $statuses, $includeDeleted, $query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchOutboundMessagesAsyncWithHttpInfo
     *
     * Find messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  int|null $sessionId Find messages by session ID. (optional)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchOutboundMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $lastId = null, $ids = null, $sessionId = null, $statuses = null, $includeDeleted = 0, $query = null, string $contentType = self::contentTypes['searchOutboundMessages'][0])
    {
        $returnType = '\TextMagic\Models\SearchOutboundMessagesPaginatedResponse';
        $request = $this->searchOutboundMessagesRequest($page, $limit, $lastId, $ids, $sessionId, $statuses, $includeDeleted, $query, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchOutboundMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  int|null $lastId Filter results by ID, selecting all values lesser than the specified ID. Note that the \\&#39;page\\&#39; parameter is ignored when \\&#39;lastId\\&#39; is specified. (optional)
     * @param  string|null $ids Find message by ID(s). (optional)
     * @param  int|null $sessionId Find messages by session ID. (optional)
     * @param  string|null $statuses Find messages by status. (optional)
     * @param  int|null $includeDeleted Search also in deleted messages. (optional, default to 0)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchOutboundMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchOutboundMessagesRequest($page = 1, $limit = 10, $lastId = null, $ids = null, $sessionId = null, $statuses = null, $includeDeleted = 0, $query = null, string $contentType = self::contentTypes['searchOutboundMessages'][0])
    {




        if ($ids !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling TextMagicApi.searchOutboundMessages, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        





        $resourcePath = '/api/v2/messages/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastId,
            'lastId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sessionId,
            'sessionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeDeleted,
            'includeDeleted', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchScheduledMessages
     *
     * Find scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $ids Find schedules by ID(s). (optional)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchScheduledMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchScheduledMessages($page = 1, $limit = 10, $query = null, $ids = null, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchScheduledMessages'][0])
    {
        list($response) = $this->searchScheduledMessagesWithHttpInfo($page, $limit, $query, $ids, $status, $orderBy, $direction, $contentType);
        return $response;
    }

    /**
     * Operation searchScheduledMessagesWithHttpInfo
     *
     * Find scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $ids Find schedules by ID(s). (optional)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledMessages'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchScheduledMessagesPaginatedResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchScheduledMessagesWithHttpInfo($page = 1, $limit = 10, $query = null, $ids = null, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchScheduledMessages'][0])
    {
        $request = $this->searchScheduledMessagesRequest($page, $limit, $query, $ids, $status, $orderBy, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchScheduledMessagesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchScheduledMessagesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchScheduledMessagesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchScheduledMessagesAsync
     *
     * Find scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $ids Find schedules by ID(s). (optional)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchScheduledMessagesAsync($page = 1, $limit = 10, $query = null, $ids = null, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchScheduledMessages'][0])
    {
        return $this->searchScheduledMessagesAsyncWithHttpInfo($page, $limit, $query, $ids, $status, $orderBy, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchScheduledMessagesAsyncWithHttpInfo
     *
     * Find scheduled messages
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $ids Find schedules by ID(s). (optional)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchScheduledMessagesAsyncWithHttpInfo($page = 1, $limit = 10, $query = null, $ids = null, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchScheduledMessages'][0])
    {
        $returnType = '\TextMagic\Models\SearchScheduledMessagesPaginatedResponse';
        $request = $this->searchScheduledMessagesRequest($page, $limit, $query, $ids, $status, $orderBy, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchScheduledMessages'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $query Find messages by specified search query. (optional)
     * @param  string|null $ids Find schedules by ID(s). (optional)
     * @param  string|null $status Fetch schedules with a specific status: a - actual, c - completed, x - all. (optional, default to 'x')
     * @param  string|null $orderBy Order results by some field. Default is id. (optional, default to 'id')
     * @param  string|null $direction Order direction. Default is desc. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchScheduledMessagesRequest($page = 1, $limit = 10, $query = null, $ids = null, $status = 'x', $orderBy = 'id', $direction = 'desc', string $contentType = self::contentTypes['searchScheduledMessages'][0])
    {




        if ($ids !== null && !preg_match("/^(\\d+)(,\\d+)*$/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling TextMagicApi.searchScheduledMessages, must conform to the pattern /^(\\d+)(,\\d+)*$/.");
        }
        




        $resourcePath = '/api/v2/schedules/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchTemplates
     *
     * Find templates by criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find template by ID(s). (optional)
     * @param  string|null $name Find template by name. (optional)
     * @param  string|null $content Find template by content. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTemplates'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SearchTemplatesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function searchTemplates($page = 1, $limit = 10, $ids = null, $name = null, $content = null, string $contentType = self::contentTypes['searchTemplates'][0])
    {
        list($response) = $this->searchTemplatesWithHttpInfo($page, $limit, $ids, $name, $content, $contentType);
        return $response;
    }

    /**
     * Operation searchTemplatesWithHttpInfo
     *
     * Find templates by criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find template by ID(s). (optional)
     * @param  string|null $name Find template by name. (optional)
     * @param  string|null $content Find template by content. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTemplates'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SearchTemplatesPaginatedResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchTemplatesWithHttpInfo($page = 1, $limit = 10, $ids = null, $name = null, $content = null, string $contentType = self::contentTypes['searchTemplates'][0])
    {
        $request = $this->searchTemplatesRequest($page, $limit, $ids, $name, $content, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SearchTemplatesPaginatedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SearchTemplatesPaginatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SearchTemplatesPaginatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchTemplatesAsync
     *
     * Find templates by criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find template by ID(s). (optional)
     * @param  string|null $name Find template by name. (optional)
     * @param  string|null $content Find template by content. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTemplatesAsync($page = 1, $limit = 10, $ids = null, $name = null, $content = null, string $contentType = self::contentTypes['searchTemplates'][0])
    {
        return $this->searchTemplatesAsyncWithHttpInfo($page, $limit, $ids, $name, $content, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchTemplatesAsyncWithHttpInfo
     *
     * Find templates by criteria
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find template by ID(s). (optional)
     * @param  string|null $name Find template by name. (optional)
     * @param  string|null $content Find template by content. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTemplatesAsyncWithHttpInfo($page = 1, $limit = 10, $ids = null, $name = null, $content = null, string $contentType = self::contentTypes['searchTemplates'][0])
    {
        $returnType = '\TextMagic\Models\SearchTemplatesPaginatedResponse';
        $request = $this->searchTemplatesRequest($page, $limit, $ids, $name, $content, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchTemplates'
     *
     * @param  int|null $page Fetch specified results page. (optional, default to 1)
     * @param  int|null $limit The number of results per page. (optional, default to 10)
     * @param  string|null $ids Find template by ID(s). (optional)
     * @param  string|null $name Find template by name. (optional)
     * @param  string|null $content Find template by content. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchTemplatesRequest($page = 1, $limit = 10, $ids = null, $name = null, $content = null, string $contentType = self::contentTypes['searchTemplates'][0])
    {







        $resourcePath = '/api/v2/templates/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content,
            'content', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendMessage
     *
     * Send message
     *
     * @param  \TextMagic\Models\SendMessageRequest $sendMessageInputObject sendMessageInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\SendMessageResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function sendMessage($sendMessageInputObject, string $contentType = self::contentTypes['sendMessage'][0])
    {
        list($response) = $this->sendMessageWithHttpInfo($sendMessageInputObject, $contentType);
        return $response;
    }

    /**
     * Operation sendMessageWithHttpInfo
     *
     * Send message
     *
     * @param  \TextMagic\Models\SendMessageRequest $sendMessageInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMessage'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\SendMessageResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendMessageWithHttpInfo($sendMessageInputObject, string $contentType = self::contentTypes['sendMessage'][0])
    {
        $request = $this->sendMessageRequest($sendMessageInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\SendMessageResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\SendMessageResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\SendMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation sendMessageAsync
     *
     * Send message
     *
     * @param  \TextMagic\Models\SendMessageRequest $sendMessageInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMessageAsync($sendMessageInputObject, string $contentType = self::contentTypes['sendMessage'][0])
    {
        return $this->sendMessageAsyncWithHttpInfo($sendMessageInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendMessageAsyncWithHttpInfo
     *
     * Send message
     *
     * @param  \TextMagic\Models\SendMessageRequest $sendMessageInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMessageAsyncWithHttpInfo($sendMessageInputObject, string $contentType = self::contentTypes['sendMessage'][0])
    {
        $returnType = '\TextMagic\Models\SendMessageResponse';
        $request = $this->sendMessageRequest($sendMessageInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendMessage'
     *
     * @param  \TextMagic\Models\SendMessageRequest $sendMessageInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendMessageRequest($sendMessageInputObject, string $contentType = self::contentTypes['sendMessage'][0])
    {

        // verify the required parameter 'sendMessageInputObject' is set
        if ($sendMessageInputObject === null || (is_array($sendMessageInputObject) && count($sendMessageInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendMessageInputObject when calling sendMessage'
            );
        }


        $resourcePath = '/api/v2/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sendMessageInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sendMessageInputObject));
            } else {
                $httpBody = $sendMessageInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setChatStatus
     *
     * Change chat status
     *
     * @param  \TextMagic\Models\SetChatStatusRequest $setChatStatusInputObject setChatStatusInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChatStatus'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function setChatStatus($setChatStatusInputObject, string $contentType = self::contentTypes['setChatStatus'][0])
    {
        list($response) = $this->setChatStatusWithHttpInfo($setChatStatusInputObject, $contentType);
        return $response;
    }

    /**
     * Operation setChatStatusWithHttpInfo
     *
     * Change chat status
     *
     * @param  \TextMagic\Models\SetChatStatusRequest $setChatStatusInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChatStatus'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setChatStatusWithHttpInfo($setChatStatusInputObject, string $contentType = self::contentTypes['setChatStatus'][0])
    {
        $request = $this->setChatStatusRequest($setChatStatusInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setChatStatusAsync
     *
     * Change chat status
     *
     * @param  \TextMagic\Models\SetChatStatusRequest $setChatStatusInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChatStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChatStatusAsync($setChatStatusInputObject, string $contentType = self::contentTypes['setChatStatus'][0])
    {
        return $this->setChatStatusAsyncWithHttpInfo($setChatStatusInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setChatStatusAsyncWithHttpInfo
     *
     * Change chat status
     *
     * @param  \TextMagic\Models\SetChatStatusRequest $setChatStatusInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChatStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChatStatusAsyncWithHttpInfo($setChatStatusInputObject, string $contentType = self::contentTypes['setChatStatus'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->setChatStatusRequest($setChatStatusInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setChatStatus'
     *
     * @param  \TextMagic\Models\SetChatStatusRequest $setChatStatusInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChatStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setChatStatusRequest($setChatStatusInputObject, string $contentType = self::contentTypes['setChatStatus'][0])
    {

        // verify the required parameter 'setChatStatusInputObject' is set
        if ($setChatStatusInputObject === null || (is_array($setChatStatusInputObject) && count($setChatStatusInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setChatStatusInputObject when calling setChatStatus'
            );
        }


        $resourcePath = '/api/v2/chats/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($setChatStatusInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($setChatStatusInputObject));
            } else {
                $httpBody = $setChatStatusInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unblockContact
     *
     * Unblock a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $unblockContactInputObject unblockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unblockContact($unblockContactInputObject, string $contentType = self::contentTypes['unblockContact'][0])
    {
        $this->unblockContactWithHttpInfo($unblockContactInputObject, $contentType);
    }

    /**
     * Operation unblockContactWithHttpInfo
     *
     * Unblock a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $unblockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unblockContactWithHttpInfo($unblockContactInputObject, string $contentType = self::contentTypes['unblockContact'][0])
    {
        $request = $this->unblockContactRequest($unblockContactInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unblockContactAsync
     *
     * Unblock a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $unblockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unblockContactAsync($unblockContactInputObject, string $contentType = self::contentTypes['unblockContact'][0])
    {
        return $this->unblockContactAsyncWithHttpInfo($unblockContactInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unblockContactAsyncWithHttpInfo
     *
     * Unblock a contact by phone number
     *
     * @param  \TextMagic\Models\BlockContactRequest $unblockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unblockContactAsyncWithHttpInfo($unblockContactInputObject, string $contentType = self::contentTypes['unblockContact'][0])
    {
        $returnType = '';
        $request = $this->unblockContactRequest($unblockContactInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unblockContact'
     *
     * @param  \TextMagic\Models\BlockContactRequest $unblockContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unblockContactRequest($unblockContactInputObject, string $contentType = self::contentTypes['unblockContact'][0])
    {

        // verify the required parameter 'unblockContactInputObject' is set
        if ($unblockContactInputObject === null || (is_array($unblockContactInputObject) && count($unblockContactInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unblockContactInputObject when calling unblockContact'
            );
        }


        $resourcePath = '/api/v2/contacts/unblock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($unblockContactInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($unblockContactInputObject));
            } else {
                $httpBody = $unblockContactInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unblockContactsBulk
     *
     * Unblock contacts (bulk)
     *
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $unblockContactsBulkInputObject unblockContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContactsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unblockContactsBulk($unblockContactsBulkInputObject, string $contentType = self::contentTypes['unblockContactsBulk'][0])
    {
        $this->unblockContactsBulkWithHttpInfo($unblockContactsBulkInputObject, $contentType);
    }

    /**
     * Operation unblockContactsBulkWithHttpInfo
     *
     * Unblock contacts (bulk)
     *
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $unblockContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContactsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unblockContactsBulkWithHttpInfo($unblockContactsBulkInputObject, string $contentType = self::contentTypes['unblockContactsBulk'][0])
    {
        $request = $this->unblockContactsBulkRequest($unblockContactsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unblockContactsBulkAsync
     *
     * Unblock contacts (bulk)
     *
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $unblockContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unblockContactsBulkAsync($unblockContactsBulkInputObject, string $contentType = self::contentTypes['unblockContactsBulk'][0])
    {
        return $this->unblockContactsBulkAsyncWithHttpInfo($unblockContactsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unblockContactsBulkAsyncWithHttpInfo
     *
     * Unblock contacts (bulk)
     *
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $unblockContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unblockContactsBulkAsyncWithHttpInfo($unblockContactsBulkInputObject, string $contentType = self::contentTypes['unblockContactsBulk'][0])
    {
        $returnType = '';
        $request = $this->unblockContactsBulkRequest($unblockContactsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unblockContactsBulk'
     *
     * @param  \TextMagic\Models\UnblockContactsBulkRequest $unblockContactsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unblockContactsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unblockContactsBulkRequest($unblockContactsBulkInputObject, string $contentType = self::contentTypes['unblockContactsBulk'][0])
    {

        // verify the required parameter 'unblockContactsBulkInputObject' is set
        if ($unblockContactsBulkInputObject === null || (is_array($unblockContactsBulkInputObject) && count($unblockContactsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unblockContactsBulkInputObject when calling unblockContactsBulk'
            );
        }


        $resourcePath = '/api/v2/contacts/unblock/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($unblockContactsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($unblockContactsBulkInputObject));
            } else {
                $httpBody = $unblockContactsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unmuteChatsBulk
     *
     * Unmute chats (bulk)
     *
     * @param  \TextMagic\Models\UnmuteChatsBulkRequest $unmuteChatsBulkInputObject unmuteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unmuteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unmuteChatsBulk($unmuteChatsBulkInputObject, string $contentType = self::contentTypes['unmuteChatsBulk'][0])
    {
        $this->unmuteChatsBulkWithHttpInfo($unmuteChatsBulkInputObject, $contentType);
    }

    /**
     * Operation unmuteChatsBulkWithHttpInfo
     *
     * Unmute chats (bulk)
     *
     * @param  \TextMagic\Models\UnmuteChatsBulkRequest $unmuteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unmuteChatsBulk'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unmuteChatsBulkWithHttpInfo($unmuteChatsBulkInputObject, string $contentType = self::contentTypes['unmuteChatsBulk'][0])
    {
        $request = $this->unmuteChatsBulkRequest($unmuteChatsBulkInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unmuteChatsBulkAsync
     *
     * Unmute chats (bulk)
     *
     * @param  \TextMagic\Models\UnmuteChatsBulkRequest $unmuteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unmuteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unmuteChatsBulkAsync($unmuteChatsBulkInputObject, string $contentType = self::contentTypes['unmuteChatsBulk'][0])
    {
        return $this->unmuteChatsBulkAsyncWithHttpInfo($unmuteChatsBulkInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unmuteChatsBulkAsyncWithHttpInfo
     *
     * Unmute chats (bulk)
     *
     * @param  \TextMagic\Models\UnmuteChatsBulkRequest $unmuteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unmuteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unmuteChatsBulkAsyncWithHttpInfo($unmuteChatsBulkInputObject, string $contentType = self::contentTypes['unmuteChatsBulk'][0])
    {
        $returnType = '';
        $request = $this->unmuteChatsBulkRequest($unmuteChatsBulkInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unmuteChatsBulk'
     *
     * @param  \TextMagic\Models\UnmuteChatsBulkRequest $unmuteChatsBulkInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unmuteChatsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unmuteChatsBulkRequest($unmuteChatsBulkInputObject, string $contentType = self::contentTypes['unmuteChatsBulk'][0])
    {

        // verify the required parameter 'unmuteChatsBulkInputObject' is set
        if ($unmuteChatsBulkInputObject === null || (is_array($unmuteChatsBulkInputObject) && count($unmuteChatsBulkInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unmuteChatsBulkInputObject when calling unmuteChatsBulk'
            );
        }


        $resourcePath = '/api/v2/chats/unmute/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($unmuteChatsBulkInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($unmuteChatsBulkInputObject));
            } else {
                $httpBody = $unmuteChatsBulkInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unsubscribeContact
     *
     * Manually unsubscribe a contact
     *
     * @param  \TextMagic\Models\UnsubscribeContactRequest $unsubscribeContactInputObject unsubscribeContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscribeContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function unsubscribeContact($unsubscribeContactInputObject, string $contentType = self::contentTypes['unsubscribeContact'][0])
    {
        list($response) = $this->unsubscribeContactWithHttpInfo($unsubscribeContactInputObject, $contentType);
        return $response;
    }

    /**
     * Operation unsubscribeContactWithHttpInfo
     *
     * Manually unsubscribe a contact
     *
     * @param  \TextMagic\Models\UnsubscribeContactRequest $unsubscribeContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscribeContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function unsubscribeContactWithHttpInfo($unsubscribeContactInputObject, string $contentType = self::contentTypes['unsubscribeContact'][0])
    {
        $request = $this->unsubscribeContactRequest($unsubscribeContactInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unsubscribeContactAsync
     *
     * Manually unsubscribe a contact
     *
     * @param  \TextMagic\Models\UnsubscribeContactRequest $unsubscribeContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscribeContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unsubscribeContactAsync($unsubscribeContactInputObject, string $contentType = self::contentTypes['unsubscribeContact'][0])
    {
        return $this->unsubscribeContactAsyncWithHttpInfo($unsubscribeContactInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unsubscribeContactAsyncWithHttpInfo
     *
     * Manually unsubscribe a contact
     *
     * @param  \TextMagic\Models\UnsubscribeContactRequest $unsubscribeContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscribeContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unsubscribeContactAsyncWithHttpInfo($unsubscribeContactInputObject, string $contentType = self::contentTypes['unsubscribeContact'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->unsubscribeContactRequest($unsubscribeContactInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unsubscribeContact'
     *
     * @param  \TextMagic\Models\UnsubscribeContactRequest $unsubscribeContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscribeContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unsubscribeContactRequest($unsubscribeContactInputObject, string $contentType = self::contentTypes['unsubscribeContact'][0])
    {

        // verify the required parameter 'unsubscribeContactInputObject' is set
        if ($unsubscribeContactInputObject === null || (is_array($unsubscribeContactInputObject) && count($unsubscribeContactInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unsubscribeContactInputObject when calling unsubscribeContact'
            );
        }


        $resourcePath = '/api/v2/unsubscribers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($unsubscribeContactInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($unsubscribeContactInputObject));
            } else {
                $httpBody = $unsubscribeContactInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBalanceNotificationSettings
     *
     * Update balance notification settings
     *
     * @param  \TextMagic\Models\UpdateBalanceNotificationSettingsRequest $updateBalanceNotificationSettingsInputObject updateBalanceNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateBalanceNotificationSettings($updateBalanceNotificationSettingsInputObject, string $contentType = self::contentTypes['updateBalanceNotificationSettings'][0])
    {
        $this->updateBalanceNotificationSettingsWithHttpInfo($updateBalanceNotificationSettingsInputObject, $contentType);
    }

    /**
     * Operation updateBalanceNotificationSettingsWithHttpInfo
     *
     * Update balance notification settings
     *
     * @param  \TextMagic\Models\UpdateBalanceNotificationSettingsRequest $updateBalanceNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBalanceNotificationSettingsWithHttpInfo($updateBalanceNotificationSettingsInputObject, string $contentType = self::contentTypes['updateBalanceNotificationSettings'][0])
    {
        $request = $this->updateBalanceNotificationSettingsRequest($updateBalanceNotificationSettingsInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateBalanceNotificationSettingsAsync
     *
     * Update balance notification settings
     *
     * @param  \TextMagic\Models\UpdateBalanceNotificationSettingsRequest $updateBalanceNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBalanceNotificationSettingsAsync($updateBalanceNotificationSettingsInputObject, string $contentType = self::contentTypes['updateBalanceNotificationSettings'][0])
    {
        return $this->updateBalanceNotificationSettingsAsyncWithHttpInfo($updateBalanceNotificationSettingsInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBalanceNotificationSettingsAsyncWithHttpInfo
     *
     * Update balance notification settings
     *
     * @param  \TextMagic\Models\UpdateBalanceNotificationSettingsRequest $updateBalanceNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBalanceNotificationSettingsAsyncWithHttpInfo($updateBalanceNotificationSettingsInputObject, string $contentType = self::contentTypes['updateBalanceNotificationSettings'][0])
    {
        $returnType = '';
        $request = $this->updateBalanceNotificationSettingsRequest($updateBalanceNotificationSettingsInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBalanceNotificationSettings'
     *
     * @param  \TextMagic\Models\UpdateBalanceNotificationSettingsRequest $updateBalanceNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBalanceNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateBalanceNotificationSettingsRequest($updateBalanceNotificationSettingsInputObject, string $contentType = self::contentTypes['updateBalanceNotificationSettings'][0])
    {

        // verify the required parameter 'updateBalanceNotificationSettingsInputObject' is set
        if ($updateBalanceNotificationSettingsInputObject === null || (is_array($updateBalanceNotificationSettingsInputObject) && count($updateBalanceNotificationSettingsInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateBalanceNotificationSettingsInputObject when calling updateBalanceNotificationSettings'
            );
        }


        $resourcePath = '/api/v2/user/notification/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateBalanceNotificationSettingsInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateBalanceNotificationSettingsInputObject));
            } else {
                $httpBody = $updateBalanceNotificationSettingsInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCallbackSettings
     *
     * Update callback URL settings
     *
     * @param  \TextMagic\Models\UpdateCallbackSettingsRequest $updateCallbackSettingsInputObject updateCallbackSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCallbackSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateCallbackSettings($updateCallbackSettingsInputObject, string $contentType = self::contentTypes['updateCallbackSettings'][0])
    {
        $this->updateCallbackSettingsWithHttpInfo($updateCallbackSettingsInputObject, $contentType);
    }

    /**
     * Operation updateCallbackSettingsWithHttpInfo
     *
     * Update callback URL settings
     *
     * @param  \TextMagic\Models\UpdateCallbackSettingsRequest $updateCallbackSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCallbackSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCallbackSettingsWithHttpInfo($updateCallbackSettingsInputObject, string $contentType = self::contentTypes['updateCallbackSettings'][0])
    {
        $request = $this->updateCallbackSettingsRequest($updateCallbackSettingsInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCallbackSettingsAsync
     *
     * Update callback URL settings
     *
     * @param  \TextMagic\Models\UpdateCallbackSettingsRequest $updateCallbackSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCallbackSettingsAsync($updateCallbackSettingsInputObject, string $contentType = self::contentTypes['updateCallbackSettings'][0])
    {
        return $this->updateCallbackSettingsAsyncWithHttpInfo($updateCallbackSettingsInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCallbackSettingsAsyncWithHttpInfo
     *
     * Update callback URL settings
     *
     * @param  \TextMagic\Models\UpdateCallbackSettingsRequest $updateCallbackSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCallbackSettingsAsyncWithHttpInfo($updateCallbackSettingsInputObject, string $contentType = self::contentTypes['updateCallbackSettings'][0])
    {
        $returnType = '';
        $request = $this->updateCallbackSettingsRequest($updateCallbackSettingsInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCallbackSettings'
     *
     * @param  \TextMagic\Models\UpdateCallbackSettingsRequest $updateCallbackSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCallbackSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCallbackSettingsRequest($updateCallbackSettingsInputObject, string $contentType = self::contentTypes['updateCallbackSettings'][0])
    {

        // verify the required parameter 'updateCallbackSettingsInputObject' is set
        if ($updateCallbackSettingsInputObject === null || (is_array($updateCallbackSettingsInputObject) && count($updateCallbackSettingsInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCallbackSettingsInputObject when calling updateCallbackSettings'
            );
        }


        $resourcePath = '/api/v2/callback/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCallbackSettingsInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCallbackSettingsInputObject));
            } else {
                $httpBody = $updateCallbackSettingsInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateChatDesktopNotificationSettings
     *
     * Update chat desktop notification settings
     *
     * @param  \TextMagic\Models\UpdateChatDesktopNotificationSettingsRequest $updateChatDesktopNotificationSettingsInputObject updateChatDesktopNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChatDesktopNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateChatDesktopNotificationSettings($updateChatDesktopNotificationSettingsInputObject, string $contentType = self::contentTypes['updateChatDesktopNotificationSettings'][0])
    {
        $this->updateChatDesktopNotificationSettingsWithHttpInfo($updateChatDesktopNotificationSettingsInputObject, $contentType);
    }

    /**
     * Operation updateChatDesktopNotificationSettingsWithHttpInfo
     *
     * Update chat desktop notification settings
     *
     * @param  \TextMagic\Models\UpdateChatDesktopNotificationSettingsRequest $updateChatDesktopNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChatDesktopNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateChatDesktopNotificationSettingsWithHttpInfo($updateChatDesktopNotificationSettingsInputObject, string $contentType = self::contentTypes['updateChatDesktopNotificationSettings'][0])
    {
        $request = $this->updateChatDesktopNotificationSettingsRequest($updateChatDesktopNotificationSettingsInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateChatDesktopNotificationSettingsAsync
     *
     * Update chat desktop notification settings
     *
     * @param  \TextMagic\Models\UpdateChatDesktopNotificationSettingsRequest $updateChatDesktopNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChatDesktopNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateChatDesktopNotificationSettingsAsync($updateChatDesktopNotificationSettingsInputObject, string $contentType = self::contentTypes['updateChatDesktopNotificationSettings'][0])
    {
        return $this->updateChatDesktopNotificationSettingsAsyncWithHttpInfo($updateChatDesktopNotificationSettingsInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateChatDesktopNotificationSettingsAsyncWithHttpInfo
     *
     * Update chat desktop notification settings
     *
     * @param  \TextMagic\Models\UpdateChatDesktopNotificationSettingsRequest $updateChatDesktopNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChatDesktopNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateChatDesktopNotificationSettingsAsyncWithHttpInfo($updateChatDesktopNotificationSettingsInputObject, string $contentType = self::contentTypes['updateChatDesktopNotificationSettings'][0])
    {
        $returnType = '';
        $request = $this->updateChatDesktopNotificationSettingsRequest($updateChatDesktopNotificationSettingsInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateChatDesktopNotificationSettings'
     *
     * @param  \TextMagic\Models\UpdateChatDesktopNotificationSettingsRequest $updateChatDesktopNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChatDesktopNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateChatDesktopNotificationSettingsRequest($updateChatDesktopNotificationSettingsInputObject, string $contentType = self::contentTypes['updateChatDesktopNotificationSettings'][0])
    {

        // verify the required parameter 'updateChatDesktopNotificationSettingsInputObject' is set
        if ($updateChatDesktopNotificationSettingsInputObject === null || (is_array($updateChatDesktopNotificationSettingsInputObject) && count($updateChatDesktopNotificationSettingsInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateChatDesktopNotificationSettingsInputObject when calling updateChatDesktopNotificationSettings'
            );
        }


        $resourcePath = '/api/v2/user/desktop/notification';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateChatDesktopNotificationSettingsInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateChatDesktopNotificationSettingsInputObject));
            } else {
                $httpBody = $updateChatDesktopNotificationSettingsInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContact
     *
     * Edit a contact
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\UpdateContactRequest $updateContactInputObject updateContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function updateContact($id, $updateContactInputObject, string $contentType = self::contentTypes['updateContact'][0])
    {
        list($response) = $this->updateContactWithHttpInfo($id, $updateContactInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateContactWithHttpInfo
     *
     * Edit a contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactRequest $updateContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContact'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactWithHttpInfo($id, $updateContactInputObject, string $contentType = self::contentTypes['updateContact'][0])
    {
        $request = $this->updateContactRequest($id, $updateContactInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateContactAsync
     *
     * Edit a contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactRequest $updateContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAsync($id, $updateContactInputObject, string $contentType = self::contentTypes['updateContact'][0])
    {
        return $this->updateContactAsyncWithHttpInfo($id, $updateContactInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAsyncWithHttpInfo
     *
     * Edit a contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactRequest $updateContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAsyncWithHttpInfo($id, $updateContactInputObject, string $contentType = self::contentTypes['updateContact'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateContactRequest($id, $updateContactInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContact'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactRequest $updateContactInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactRequest($id, $updateContactInputObject, string $contentType = self::contentTypes['updateContact'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateContact'
            );
        }

        // verify the required parameter 'updateContactInputObject' is set
        if ($updateContactInputObject === null || (is_array($updateContactInputObject) && count($updateContactInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateContactInputObject when calling updateContact'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}/normalized';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateContactInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateContactInputObject));
            } else {
                $httpBody = $updateContactInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactNote
     *
     * Update a contact note
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\UpdateContactNoteRequest $updateContactNoteInputObject updateContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function updateContactNote($id, $updateContactNoteInputObject, string $contentType = self::contentTypes['updateContactNote'][0])
    {
        list($response) = $this->updateContactNoteWithHttpInfo($id, $updateContactNoteInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateContactNoteWithHttpInfo
     *
     * Update a contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactNoteRequest $updateContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactNote'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactNoteWithHttpInfo($id, $updateContactNoteInputObject, string $contentType = self::contentTypes['updateContactNote'][0])
    {
        $request = $this->updateContactNoteRequest($id, $updateContactNoteInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateContactNoteAsync
     *
     * Update a contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactNoteRequest $updateContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactNoteAsync($id, $updateContactNoteInputObject, string $contentType = self::contentTypes['updateContactNote'][0])
    {
        return $this->updateContactNoteAsyncWithHttpInfo($id, $updateContactNoteInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactNoteAsyncWithHttpInfo
     *
     * Update a contact note
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactNoteRequest $updateContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactNoteAsyncWithHttpInfo($id, $updateContactNoteInputObject, string $contentType = self::contentTypes['updateContactNote'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateContactNoteRequest($id, $updateContactNoteInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactNote'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateContactNoteRequest $updateContactNoteInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactNoteRequest($id, $updateContactNoteInputObject, string $contentType = self::contentTypes['updateContactNote'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateContactNote'
            );
        }

        // verify the required parameter 'updateContactNoteInputObject' is set
        if ($updateContactNoteInputObject === null || (is_array($updateContactNoteInputObject) && count($updateContactNoteInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateContactNoteInputObject when calling updateContactNote'
            );
        }


        $resourcePath = '/api/v2/notes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateContactNoteInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateContactNoteInputObject));
            } else {
                $httpBody = $updateContactNoteInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCurrentUser
     *
     * Edit current account info
     *
     * @param  \TextMagic\Models\UpdateCurrentUserRequest $updateCurrentUserInputObject updateCurrentUserInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCurrentUser'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UpdateCurrentUserResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function updateCurrentUser($updateCurrentUserInputObject, string $contentType = self::contentTypes['updateCurrentUser'][0])
    {
        list($response) = $this->updateCurrentUserWithHttpInfo($updateCurrentUserInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateCurrentUserWithHttpInfo
     *
     * Edit current account info
     *
     * @param  \TextMagic\Models\UpdateCurrentUserRequest $updateCurrentUserInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCurrentUser'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UpdateCurrentUserResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCurrentUserWithHttpInfo($updateCurrentUserInputObject, string $contentType = self::contentTypes['updateCurrentUser'][0])
    {
        $request = $this->updateCurrentUserRequest($updateCurrentUserInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UpdateCurrentUserResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UpdateCurrentUserResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UpdateCurrentUserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCurrentUserAsync
     *
     * Edit current account info
     *
     * @param  \TextMagic\Models\UpdateCurrentUserRequest $updateCurrentUserInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCurrentUserAsync($updateCurrentUserInputObject, string $contentType = self::contentTypes['updateCurrentUser'][0])
    {
        return $this->updateCurrentUserAsyncWithHttpInfo($updateCurrentUserInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCurrentUserAsyncWithHttpInfo
     *
     * Edit current account info
     *
     * @param  \TextMagic\Models\UpdateCurrentUserRequest $updateCurrentUserInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCurrentUserAsyncWithHttpInfo($updateCurrentUserInputObject, string $contentType = self::contentTypes['updateCurrentUser'][0])
    {
        $returnType = '\TextMagic\Models\UpdateCurrentUserResponse';
        $request = $this->updateCurrentUserRequest($updateCurrentUserInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCurrentUser'
     *
     * @param  \TextMagic\Models\UpdateCurrentUserRequest $updateCurrentUserInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCurrentUserRequest($updateCurrentUserInputObject, string $contentType = self::contentTypes['updateCurrentUser'][0])
    {

        // verify the required parameter 'updateCurrentUserInputObject' is set
        if ($updateCurrentUserInputObject === null || (is_array($updateCurrentUserInputObject) && count($updateCurrentUserInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCurrentUserInputObject when calling updateCurrentUser'
            );
        }


        $resourcePath = '/api/v2/user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCurrentUserInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCurrentUserInputObject));
            } else {
                $httpBody = $updateCurrentUserInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomField
     *
     * Edit a custom field
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\CreateCustomFieldRequest $updateCustomFieldInputObject updateCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function updateCustomField($id, $updateCustomFieldInputObject, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        list($response) = $this->updateCustomFieldWithHttpInfo($id, $updateCustomFieldInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateCustomFieldWithHttpInfo
     *
     * Edit a custom field
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateCustomFieldRequest $updateCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomFieldWithHttpInfo($id, $updateCustomFieldInputObject, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        $request = $this->updateCustomFieldRequest($id, $updateCustomFieldInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCustomFieldAsync
     *
     * Edit a custom field
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateCustomFieldRequest $updateCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldAsync($id, $updateCustomFieldInputObject, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        return $this->updateCustomFieldAsyncWithHttpInfo($id, $updateCustomFieldInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomFieldAsyncWithHttpInfo
     *
     * Edit a custom field
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateCustomFieldRequest $updateCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldAsyncWithHttpInfo($id, $updateCustomFieldInputObject, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateCustomFieldRequest($id, $updateCustomFieldInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomField'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateCustomFieldRequest $updateCustomFieldInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCustomFieldRequest($id, $updateCustomFieldInputObject, string $contentType = self::contentTypes['updateCustomField'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateCustomField'
            );
        }

        // verify the required parameter 'updateCustomFieldInputObject' is set
        if ($updateCustomFieldInputObject === null || (is_array($updateCustomFieldInputObject) && count($updateCustomFieldInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCustomFieldInputObject when calling updateCustomField'
            );
        }


        $resourcePath = '/api/v2/customfields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCustomFieldInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCustomFieldInputObject));
            } else {
                $httpBody = $updateCustomFieldInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomFieldValue
     *
     * Edit the custom field value of a specified contact
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\UpdateCustomFieldValueRequest $updateCustomFieldValueInputObject updateCustomFieldValueInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomFieldValue'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function updateCustomFieldValue($id, $updateCustomFieldValueInputObject, string $contentType = self::contentTypes['updateCustomFieldValue'][0])
    {
        list($response) = $this->updateCustomFieldValueWithHttpInfo($id, $updateCustomFieldValueInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateCustomFieldValueWithHttpInfo
     *
     * Edit the custom field value of a specified contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateCustomFieldValueRequest $updateCustomFieldValueInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomFieldValue'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomFieldValueWithHttpInfo($id, $updateCustomFieldValueInputObject, string $contentType = self::contentTypes['updateCustomFieldValue'][0])
    {
        $request = $this->updateCustomFieldValueRequest($id, $updateCustomFieldValueInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCustomFieldValueAsync
     *
     * Edit the custom field value of a specified contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateCustomFieldValueRequest $updateCustomFieldValueInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomFieldValue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldValueAsync($id, $updateCustomFieldValueInputObject, string $contentType = self::contentTypes['updateCustomFieldValue'][0])
    {
        return $this->updateCustomFieldValueAsyncWithHttpInfo($id, $updateCustomFieldValueInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomFieldValueAsyncWithHttpInfo
     *
     * Edit the custom field value of a specified contact
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateCustomFieldValueRequest $updateCustomFieldValueInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomFieldValue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldValueAsyncWithHttpInfo($id, $updateCustomFieldValueInputObject, string $contentType = self::contentTypes['updateCustomFieldValue'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateCustomFieldValueRequest($id, $updateCustomFieldValueInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomFieldValue'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateCustomFieldValueRequest $updateCustomFieldValueInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomFieldValue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCustomFieldValueRequest($id, $updateCustomFieldValueInputObject, string $contentType = self::contentTypes['updateCustomFieldValue'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateCustomFieldValue'
            );
        }

        // verify the required parameter 'updateCustomFieldValueInputObject' is set
        if ($updateCustomFieldValueInputObject === null || (is_array($updateCustomFieldValueInputObject) && count($updateCustomFieldValueInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCustomFieldValueInputObject when calling updateCustomFieldValue'
            );
        }


        $resourcePath = '/api/v2/customfields/{id}/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCustomFieldValueInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCustomFieldValueInputObject));
            } else {
                $httpBody = $updateCustomFieldValueInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInboundMessagesNotificationSettings
     *
     * Update inbound messages notification settings
     *
     * @param  \TextMagic\Models\UpdateInboundMessagesNotificationSettingsRequest $updateInboundMessagesNotificationSettingsInputObject updateInboundMessagesNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateInboundMessagesNotificationSettings($updateInboundMessagesNotificationSettingsInputObject, string $contentType = self::contentTypes['updateInboundMessagesNotificationSettings'][0])
    {
        $this->updateInboundMessagesNotificationSettingsWithHttpInfo($updateInboundMessagesNotificationSettingsInputObject, $contentType);
    }

    /**
     * Operation updateInboundMessagesNotificationSettingsWithHttpInfo
     *
     * Update inbound messages notification settings
     *
     * @param  \TextMagic\Models\UpdateInboundMessagesNotificationSettingsRequest $updateInboundMessagesNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInboundMessagesNotificationSettingsWithHttpInfo($updateInboundMessagesNotificationSettingsInputObject, string $contentType = self::contentTypes['updateInboundMessagesNotificationSettings'][0])
    {
        $request = $this->updateInboundMessagesNotificationSettingsRequest($updateInboundMessagesNotificationSettingsInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateInboundMessagesNotificationSettingsAsync
     *
     * Update inbound messages notification settings
     *
     * @param  \TextMagic\Models\UpdateInboundMessagesNotificationSettingsRequest $updateInboundMessagesNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInboundMessagesNotificationSettingsAsync($updateInboundMessagesNotificationSettingsInputObject, string $contentType = self::contentTypes['updateInboundMessagesNotificationSettings'][0])
    {
        return $this->updateInboundMessagesNotificationSettingsAsyncWithHttpInfo($updateInboundMessagesNotificationSettingsInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInboundMessagesNotificationSettingsAsyncWithHttpInfo
     *
     * Update inbound messages notification settings
     *
     * @param  \TextMagic\Models\UpdateInboundMessagesNotificationSettingsRequest $updateInboundMessagesNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInboundMessagesNotificationSettingsAsyncWithHttpInfo($updateInboundMessagesNotificationSettingsInputObject, string $contentType = self::contentTypes['updateInboundMessagesNotificationSettings'][0])
    {
        $returnType = '';
        $request = $this->updateInboundMessagesNotificationSettingsRequest($updateInboundMessagesNotificationSettingsInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInboundMessagesNotificationSettings'
     *
     * @param  \TextMagic\Models\UpdateInboundMessagesNotificationSettingsRequest $updateInboundMessagesNotificationSettingsInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInboundMessagesNotificationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateInboundMessagesNotificationSettingsRequest($updateInboundMessagesNotificationSettingsInputObject, string $contentType = self::contentTypes['updateInboundMessagesNotificationSettings'][0])
    {

        // verify the required parameter 'updateInboundMessagesNotificationSettingsInputObject' is set
        if ($updateInboundMessagesNotificationSettingsInputObject === null || (is_array($updateInboundMessagesNotificationSettingsInputObject) && count($updateInboundMessagesNotificationSettingsInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateInboundMessagesNotificationSettingsInputObject when calling updateInboundMessagesNotificationSettings'
            );
        }


        $resourcePath = '/api/v2/user/notification/inbound';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateInboundMessagesNotificationSettingsInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateInboundMessagesNotificationSettingsInputObject));
            } else {
                $httpBody = $updateInboundMessagesNotificationSettingsInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateList
     *
     * Edit a list
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\UpdateListRequest|null $updateListObject updateListObject (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse
     */
    public function updateList($id, $updateListObject = null, string $contentType = self::contentTypes['updateList'][0])
    {
        list($response) = $this->updateListWithHttpInfo($id, $updateListObject, $contentType);
        return $response;
    }

    /**
     * Operation updateListWithHttpInfo
     *
     * Edit a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateListRequest|null $updateListObject (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateList'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateListWithHttpInfo($id, $updateListObject = null, string $contentType = self::contentTypes['updateList'][0])
    {
        $request = $this->updateListRequest($id, $updateListObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateListAsync
     *
     * Edit a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateListRequest|null $updateListObject (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListAsync($id, $updateListObject = null, string $contentType = self::contentTypes['updateList'][0])
    {
        return $this->updateListAsyncWithHttpInfo($id, $updateListObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateListAsyncWithHttpInfo
     *
     * Edit a list
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateListRequest|null $updateListObject (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListAsyncWithHttpInfo($id, $updateListObject = null, string $contentType = self::contentTypes['updateList'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateListRequest($id, $updateListObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateList'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\UpdateListRequest|null $updateListObject (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateListRequest($id, $updateListObject = null, string $contentType = self::contentTypes['updateList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateList'
            );
        }



        $resourcePath = '/api/v2/lists/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateListObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateListObject));
            } else {
                $httpBody = $updateListObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSenderSetting
     *
     * Change sender settings
     *
     * @param  \TextMagic\Models\UpdateSenderSettingRequest $updateSenderSettingInputObject updateSenderSettingInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSenderSetting'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSenderSetting($updateSenderSettingInputObject, string $contentType = self::contentTypes['updateSenderSetting'][0])
    {
        $this->updateSenderSettingWithHttpInfo($updateSenderSettingInputObject, $contentType);
    }

    /**
     * Operation updateSenderSettingWithHttpInfo
     *
     * Change sender settings
     *
     * @param  \TextMagic\Models\UpdateSenderSettingRequest $updateSenderSettingInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSenderSetting'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSenderSettingWithHttpInfo($updateSenderSettingInputObject, string $contentType = self::contentTypes['updateSenderSetting'][0])
    {
        $request = $this->updateSenderSettingRequest($updateSenderSettingInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateSenderSettingAsync
     *
     * Change sender settings
     *
     * @param  \TextMagic\Models\UpdateSenderSettingRequest $updateSenderSettingInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSenderSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSenderSettingAsync($updateSenderSettingInputObject, string $contentType = self::contentTypes['updateSenderSetting'][0])
    {
        return $this->updateSenderSettingAsyncWithHttpInfo($updateSenderSettingInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSenderSettingAsyncWithHttpInfo
     *
     * Change sender settings
     *
     * @param  \TextMagic\Models\UpdateSenderSettingRequest $updateSenderSettingInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSenderSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSenderSettingAsyncWithHttpInfo($updateSenderSettingInputObject, string $contentType = self::contentTypes['updateSenderSetting'][0])
    {
        $returnType = '';
        $request = $this->updateSenderSettingRequest($updateSenderSettingInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSenderSetting'
     *
     * @param  \TextMagic\Models\UpdateSenderSettingRequest $updateSenderSettingInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSenderSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSenderSettingRequest($updateSenderSettingInputObject, string $contentType = self::contentTypes['updateSenderSetting'][0])
    {

        // verify the required parameter 'updateSenderSettingInputObject' is set
        if ($updateSenderSettingInputObject === null || (is_array($updateSenderSettingInputObject) && count($updateSenderSettingInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateSenderSettingInputObject when calling updateSenderSetting'
            );
        }


        $resourcePath = '/api/v2/sender/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateSenderSettingInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateSenderSettingInputObject));
            } else {
                $httpBody = $updateSenderSettingInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplate
     *
     * Update a template
     *
     * @param  int $id id (required)
     * @param  \TextMagic\Models\CreateTemplateRequest $updateTemplateInputObject updateTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function updateTemplate($id, $updateTemplateInputObject, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        list($response) = $this->updateTemplateWithHttpInfo($id, $updateTemplateInputObject, $contentType);
        return $response;
    }

    /**
     * Operation updateTemplateWithHttpInfo
     *
     * Update a template
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateTemplateRequest $updateTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateWithHttpInfo($id, $updateTemplateInputObject, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $request = $this->updateTemplateRequest($id, $updateTemplateInputObject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTemplateAsync
     *
     * Update a template
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateTemplateRequest $updateTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsync($id, $updateTemplateInputObject, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        return $this->updateTemplateAsyncWithHttpInfo($id, $updateTemplateInputObject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateAsyncWithHttpInfo
     *
     * Update a template
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateTemplateRequest $updateTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsyncWithHttpInfo($id, $updateTemplateInputObject, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->updateTemplateRequest($id, $updateTemplateInputObject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplate'
     *
     * @param  int $id (required)
     * @param  \TextMagic\Models\CreateTemplateRequest $updateTemplateInputObject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateRequest($id, $updateTemplateInputObject, string $contentType = self::contentTypes['updateTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTemplate'
            );
        }

        // verify the required parameter 'updateTemplateInputObject' is set
        if ($updateTemplateInputObject === null || (is_array($updateTemplateInputObject) && count($updateTemplateInputObject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateTemplateInputObject when calling updateTemplate'
            );
        }


        $resourcePath = '/api/v2/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateTemplateInputObject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateTemplateInputObject));
            } else {
                $httpBody = $updateTemplateInputObject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadAvatar
     *
     * Upload an avatar
     *
     * @param  \SplFileObject $image User avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function uploadAvatar($image, string $contentType = self::contentTypes['uploadAvatar'][0])
    {
        $this->uploadAvatarWithHttpInfo($image, $contentType);
    }

    /**
     * Operation uploadAvatarWithHttpInfo
     *
     * Upload an avatar
     *
     * @param  \SplFileObject $image User avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadAvatarWithHttpInfo($image, string $contentType = self::contentTypes['uploadAvatar'][0])
    {
        $request = $this->uploadAvatarRequest($image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadAvatarAsync
     *
     * Upload an avatar
     *
     * @param  \SplFileObject $image User avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAvatarAsync($image, string $contentType = self::contentTypes['uploadAvatar'][0])
    {
        return $this->uploadAvatarAsyncWithHttpInfo($image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAvatarAsyncWithHttpInfo
     *
     * Upload an avatar
     *
     * @param  \SplFileObject $image User avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAvatarAsyncWithHttpInfo($image, string $contentType = self::contentTypes['uploadAvatar'][0])
    {
        $returnType = '';
        $request = $this->uploadAvatarRequest($image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadAvatar'
     *
     * @param  \SplFileObject $image User avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadAvatarRequest($image, string $contentType = self::contentTypes['uploadAvatar'][0])
    {

        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling uploadAvatar'
            );
        }


        $resourcePath = '/api/v2/user/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'image' => $image,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadContactAvatar
     *
     * Upload an avatar
     *
     * @param  int $id id (required)
     * @param  \SplFileObject $image Contact avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadContactAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function uploadContactAvatar($id, $image, string $contentType = self::contentTypes['uploadContactAvatar'][0])
    {
        list($response) = $this->uploadContactAvatarWithHttpInfo($id, $image, $contentType);
        return $response;
    }

    /**
     * Operation uploadContactAvatarWithHttpInfo
     *
     * Upload an avatar
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image Contact avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadContactAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadContactAvatarWithHttpInfo($id, $image, string $contentType = self::contentTypes['uploadContactAvatar'][0])
    {
        $request = $this->uploadContactAvatarRequest($id, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadContactAvatarAsync
     *
     * Upload an avatar
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image Contact avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadContactAvatarAsync($id, $image, string $contentType = self::contentTypes['uploadContactAvatar'][0])
    {
        return $this->uploadContactAvatarAsyncWithHttpInfo($id, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadContactAvatarAsyncWithHttpInfo
     *
     * Upload an avatar
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image Contact avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadContactAvatarAsyncWithHttpInfo($id, $image, string $contentType = self::contentTypes['uploadContactAvatar'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->uploadContactAvatarRequest($id, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadContactAvatar'
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image Contact avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadContactAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadContactAvatarRequest($id, $image, string $contentType = self::contentTypes['uploadContactAvatar'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling uploadContactAvatar'
            );
        }

        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling uploadContactAvatar'
            );
        }


        $resourcePath = '/api/v2/contacts/{id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'image' => $image,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadListAvatar
     *
     * Add an avatar for a list
     *
     * @param  int $id id (required)
     * @param  \SplFileObject $image List avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadListAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse
     */
    public function uploadListAvatar($id, $image, string $contentType = self::contentTypes['uploadListAvatar'][0])
    {
        list($response) = $this->uploadListAvatarWithHttpInfo($id, $image, $contentType);
        return $response;
    }

    /**
     * Operation uploadListAvatarWithHttpInfo
     *
     * Add an avatar for a list
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image List avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadListAvatar'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\ResourceLinkResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse|\TextMagic\Models\NotFoundResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadListAvatarWithHttpInfo($id, $image, string $contentType = self::contentTypes['uploadListAvatar'][0])
    {
        $request = $this->uploadListAvatarRequest($id, $image, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\ResourceLinkResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\NotFoundResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\ResourceLinkResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\ResourceLinkResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadListAvatarAsync
     *
     * Add an avatar for a list
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image List avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadListAvatarAsync($id, $image, string $contentType = self::contentTypes['uploadListAvatar'][0])
    {
        return $this->uploadListAvatarAsyncWithHttpInfo($id, $image, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadListAvatarAsyncWithHttpInfo
     *
     * Add an avatar for a list
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image List avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadListAvatarAsyncWithHttpInfo($id, $image, string $contentType = self::contentTypes['uploadListAvatar'][0])
    {
        $returnType = '\TextMagic\Models\ResourceLinkResponse';
        $request = $this->uploadListAvatarRequest($id, $image, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadListAvatar'
     *
     * @param  int $id (required)
     * @param  \SplFileObject $image List avatar. Should be a PNG or JPG file not more than 10 MB. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadListAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadListAvatarRequest($id, $image, string $contentType = self::contentTypes['uploadListAvatar'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling uploadListAvatar'
            );
        }

        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling uploadListAvatar'
            );
        }


        $resourcePath = '/api/v2/lists/{id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'image' => $image,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadMessageAttachment
     *
     * Upload message attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageAttachment'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UploadMessageAttachmentResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function uploadMessageAttachment($file, string $contentType = self::contentTypes['uploadMessageAttachment'][0])
    {
        list($response) = $this->uploadMessageAttachmentWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation uploadMessageAttachmentWithHttpInfo
     *
     * Upload message attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageAttachment'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UploadMessageAttachmentResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadMessageAttachmentWithHttpInfo($file, string $contentType = self::contentTypes['uploadMessageAttachment'][0])
    {
        $request = $this->uploadMessageAttachmentRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UploadMessageAttachmentResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UploadMessageAttachmentResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UploadMessageAttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadMessageAttachmentAsync
     *
     * Upload message attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMessageAttachmentAsync($file, string $contentType = self::contentTypes['uploadMessageAttachment'][0])
    {
        return $this->uploadMessageAttachmentAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadMessageAttachmentAsyncWithHttpInfo
     *
     * Upload message attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMessageAttachmentAsyncWithHttpInfo($file, string $contentType = self::contentTypes['uploadMessageAttachment'][0])
    {
        $returnType = '\TextMagic\Models\UploadMessageAttachmentResponse';
        $request = $this->uploadMessageAttachmentRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadMessageAttachment'
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadMessageAttachmentRequest($file, string $contentType = self::contentTypes['uploadMessageAttachment'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadMessageAttachment'
            );
        }


        $resourcePath = '/api/v2/messages/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadMessageMMSAttachment
     *
     * Upload message mms attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageMMSAttachment'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \TextMagic\Models\UploadMessageAttachmentResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse
     */
    public function uploadMessageMMSAttachment($file, string $contentType = self::contentTypes['uploadMessageMMSAttachment'][0])
    {
        list($response) = $this->uploadMessageMMSAttachmentWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation uploadMessageMMSAttachmentWithHttpInfo
     *
     * Upload message mms attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageMMSAttachment'] to see the possible values for this operation
     *
     * @throws \TextMagic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \TextMagic\Models\UploadMessageAttachmentResponse|\TextMagic\Models\BadRequestResponse|\TextMagic\Models\UnauthorizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadMessageMMSAttachmentWithHttpInfo($file, string $contentType = self::contentTypes['uploadMessageMMSAttachment'][0])
    {
        $request = $this->uploadMessageMMSAttachmentRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UploadMessageAttachmentResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\BadRequestResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\TextMagic\Models\UnauthorizedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\TextMagic\Models\UploadMessageAttachmentResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UploadMessageAttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TextMagic\Models\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadMessageMMSAttachmentAsync
     *
     * Upload message mms attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageMMSAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMessageMMSAttachmentAsync($file, string $contentType = self::contentTypes['uploadMessageMMSAttachment'][0])
    {
        return $this->uploadMessageMMSAttachmentAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadMessageMMSAttachmentAsyncWithHttpInfo
     *
     * Upload message mms attachment
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageMMSAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadMessageMMSAttachmentAsyncWithHttpInfo($file, string $contentType = self::contentTypes['uploadMessageMMSAttachment'][0])
    {
        $returnType = '\TextMagic\Models\UploadMessageAttachmentResponse';
        $request = $this->uploadMessageMMSAttachmentRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadMessageMMSAttachment'
     *
     * @param  \SplFileObject $file Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx &amp; .vcf file formats. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadMessageMMSAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadMessageMMSAttachmentRequest($file, string $contentType = self::contentTypes['uploadMessageMMSAttachment'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadMessageMMSAttachment'
            );
        }


        $resourcePath = '/api/v2/messages/mms/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
